# Listing of Parameters
# ---------------------
# A list of names of additional shared libraries that should be loaded upon
# starting up the program. The names of these files can contain absolute or
# relative paths (relative to the directory in which you call ASPECT). In
# fact, file names that are do not contain any directory information (i.e.,
# only the name of a file such as <myplugin.so> will not be found if they are
# not located in one of the directories listed in the \texttt{LD_LIBRARY_PATH}
# environment variable. In order to load a library in the current directory,
# use <./myplugin.so> instead.
# 
# The typical use of this parameter is so that you can implement additional
# plugins in your own directories, rather than in the ASPECT source
# directories. You can then simply compile these plugins into a shared library
# without having to re-compile all of ASPECT. See the section of the manual
# discussing writing extensions for more information on how to compile
# additional files into a shared library.
set Additional shared libraries                = 

# In order to make the problem in the first time step easier to solve, we need
# a reasonable guess for the temperature and pressure. To obtain it, we use an
# adiabatic pressure and temperature field. This parameter describes what the
# `adiabatic' temperature would be at the surface of the domain (i.e. at depth
# zero). Note that this value need not coincide with the boundary condition
# posed at this point. Rather, the boundary condition may differ significantly
# from the adiabatic value, and then typically induce a thermal boundary
# layer.
# 
# For more information, see the section in the manual that discusses the
# general mathematical model.
set Adiabatic surface temperature              = 0

# In computations, the time step $k$ is chosen according to $k = c \min_K
# \frac {h_K} {\|u\|_{\infty,K} p_T}$ where $h_K$ is the diameter of cell $K$,
# and the denominator is the maximal magnitude of the velocity on cell $K$
# times the polynomial degree $p_T$ of the temperature discretization. The
# dimensionless constant $c$ is called the CFL number in this program. For
# time discretizations that have explicit components, $c$ must be less than a
# constant that depends on the details of the time discretization and that is
# no larger than one. On the other hand, for implicit discretizations such as
# the one chosen here, one can choose the time step as large as one wants (in
# particular, one can choose $c>1$) though a CFL number significantly larger
# than one will yield rather diffusive solutions. Units: None.
set CFL number                                 = 1.0

# The relative tolerance up to which the linear system for the composition
# system gets solved. See 'linear solver tolerance' for more details.
set Composition solver tolerance               = 1e-12

# The number of space dimensions you want to run this program in. ASPECT can
# run in 2 and 3 space dimensions.
set Dimension                                  = 2

# The end time of the simulation. The default value is a number so that when
# converted from years to seconds it is approximately equal to the largest
# number representable in floating point arithmetic. For all practical
# purposes, this equals infinity. Units: Years if the 'Use years in output
# instead of seconds' parameter is set; seconds otherwise.
set End time                                   = 10              # default: 5.69e+300

# A relative tolerance up to which the approximate inverse of the A block of
# the Stokes system is computed. This approximate A is used in the
# preconditioning used in the GMRES solver.
set Linear solver A block tolerance            = 1e-2

# A relative tolerance up to which the approximate inverse of the S block
# (Schur complement matrix, $S = BA^{-1}B^{T}$) of the Stokes system is
# computed. This approximate inverse of the S block is used in the
# preconditioning used in the GMRES solver.
set Linear solver S block tolerance            = 1e-6

# A relative tolerance up to which the linear Stokes systems in each time or
# nonlinear step should be solved. The absolute tolerance will then be $\| M
# x_0 - F \| \cdot \text{tol}$, where $x_0 = (0,p_0)$ is the initial guess of
# the pressure, $M$ is the system matrix, F is the right-hand side, and tol is
# the parameter specified here. We include the initial guess of the pressure
# to remove the dependency of the tolerance on the static pressure. A given
# tolerance value of 1 would mean that a zero solution vector is an acceptable
# solution since in that case the norm of the residual of the linear system
# equals the norm of the right hand side. A given tolerance of 0 would mean
# that the linear system has to be solved exactly, since this is the only way
# to obtain a zero residual.
# 
# In practice, you should choose the value of this parameter to be so that if
# you make it smaller the results of your simulation do not change any more
# (qualitatively) whereas if you make it larger, they do. For most cases, the
# default value should be sufficient. In fact, a tolerance of 1e-4 might be
# accurate enough.
set Linear solver tolerance                    = 1e-7

# The maximal number of nonlinear iterations to be performed.
set Max nonlinear iterations                   = 10

# The maximal number of nonlinear iterations to be performed in the
# pre-refinement steps. This does not include the last refinement step before
# moving to timestep 1. When this parameter has a larger value than max
# nonlinear iterations, the latter is used.
set Max nonlinear iterations in pre-refinement = 2147483647

# Set a maximum time step size for the solver to use. Generally the time step
# based on the CFL number should be sufficient, but for complicated models or
# benchmarking it may be useful to limit the time step to some value. The
# default value is a value so that when converted from years into seconds it
# equals the largest number representable by a floating point number, implying
# an unlimited time step.Units: Years or seconds, depending on the ``Use years
# in output instead of seconds'' parameter.
set Maximum time step                          = 5.69e+300

# The kind of scheme used to resolve the nonlinearity in the system. 'IMPES'
# is the classical IMplicit Pressure Explicit Saturation scheme in which ones
# solves the temperatures and Stokes equations exactly once per time step, one
# after the other. The 'iterated IMPES' scheme iterates this decoupled
# approach by alternating the solution of the temperature and Stokes systems.
# The 'iterated Stokes' scheme solves the temperature equation once at the
# beginning of each time step and then iterates out the solution of the Stokes
# equation. The 'Stokes only' scheme only solves the Stokes system and ignores
# compositions and the temperature equation (careful, the material model must
# not depend on the temperature; mostly useful for Stokes benchmarks). The
# 'Advection only'scheme only solves the temperature and other advection
# systems and instead of solving for the Stokes system, a prescribed velocity
# and pressure is used
set Nonlinear solver scheme                    = IMPES

# A relative tolerance up to which the nonlinear solver will iterate. This
# parameter is only relevant if Nonlinear solver scheme is set to 'iterated
# Stokes' or 'iterated IMPES'.
set Nonlinear solver tolerance                 = 1e-5

# As explained in the ASPECT paper (Kronbichler, Heister, and Bangerth, GJI
# 2012) we first try to solve the Stokes system in every time step using a
# GMRES iteration with a poor but cheap preconditioner. By default, we try
# whether we can converge the GMRES solver in 30 such iterations before
# deciding that we need a better preconditioner. This is sufficient for simple
# problems with constant viscosity and we never need the second phase with the
# more expensive preconditioner. On the other hand, for more complex problems,
# and in particular for problems with strongly varying viscosity, the 30 cheap
# iterations don't actually do very much good and one might skip this part
# right away. In that case, this parameter can be set to zero, i.e., we
# immediately start with the better but more expensive preconditioner.
set Number of cheap Stokes solver steps        = 30

# The name of the directory into which all output files should be placed. This
# may be an absolute or a relative path.
set Output directory                           = dg_comp_limiter # default: output

# If and how to normalize the pressure after the solution step. This is
# necessary because depending on boundary conditions, in many cases the
# pressure is only determined by the model up to a constant. On the other
# hand, we often would like to have a well-determined pressure, for example
# for table lookups of material properties in models or for comparing
# solutions. If the given value is `surface', then normalization at the end of
# each time steps adds a constant value to the pressure in such a way that the
# average pressure at the surface of the domain is zero; the surface of the
# domain is determined by asking the geometry model whether a particular face
# of the geometry has a zero or small `depth'. If the value of this parameter
# is `volume' then the pressure is normalized so that the domain average is
# zero. If `no' is given, the no pressure normalization is performed.
set Pressure normalization                     = surface

# A flag indicating whether the computation should be resumed from a
# previously saved state (if true) or start from scratch (if false). If auto
# is selected, models will be resumed if there is an existing checkpoint file,
# otherwise started from scratch.
set Resume computation                         = false

# The start time of the simulation. Units: Years if the 'Use years in output
# instead of seconds' parameter is set; seconds otherwise.
set Start time                                 = 0

# The mathematical equations that describe thermal convection only determine
# the pressure up to an arbitrary constant. On the other hand, for comparison
# and for looking up material parameters it is important that the pressure be
# normalized somehow. We do this by enforcing a particular average pressure
# value at the surface of the domain, where the geometry model determines
# where the surface is. This parameter describes what this average surface
# pressure value is supposed to be. By default, it is set to zero, but one may
# want to choose a different value for example for simulating only the volume
# of the mantle below the lithosphere, in which case the surface pressure
# should be the lithostatic pressure at the bottom of the lithosphere.
# 
# For more information, see the section in the manual that discusses the
# general mathematical model.
set Surface pressure                           = 0

# The relative tolerance up to which the linear system for the temperature
# system gets solved. See 'linear solver tolerance' for more details.
set Temperature solver tolerance               = 1e-12

# How frequently in timesteps to output timing information. This is generally
# adjusted only for debugging and timing purposes. If the value is set to zero
# it will also output timing information at the initiation timesteps.
set Timing output frequency                    = 100

# Mantle convection simulations are often focused on convection dominated
# systems. However, these codes can also be used to investigate systems where
# heat conduction plays a dominant role. This parameter indicates whether the
# simulator should also use heat conduction in determining the length of each
# time step.
set Use conduction timestep                    = false

# If set to true the linear system for the Stokes equation will be solved
# using Trilinos klu, otherwise an iterative Schur complement solver is used.
# The direct solver is only efficient for small problems.
set Use direct solver for Stokes system        = false

# When computing results for mantle convection simulations, it is often
# difficult to judge the order of magnitude of results when they are stated in
# MKS units involving seconds. Rather, some kinds of results such as
# velocities are often stated in terms of meters per year (or, sometimes,
# centimeters per year). On the other hand, for non-dimensional computations,
# one wants results in their natural unit system as used inside the code. If
# this flag is set to 'true' conversion to years happens; if it is 'false', no
# such conversion happens. Note that when 'true', some input such as
# prescribed velocities should also use years instead of seconds.
set Use years in output instead of seconds     = false           # default: true


subsection Adiabatic conditions model
  # Select one of the following models:
  # 
  # `initial profile': A model in which the adiabatic profile is calculated
  # once at the start of the model run. The gravity is assumed to be in depth
  # direction and the composition is evaluated at reference points, no lateral
  # averaging is performed. All material parameters are used from the material
  # model plugin.
  set Model name = initial profile
end


subsection Boundary composition model
  # Select one of the following models:
  # 
  # `ascii data': Implementation of a model in which the boundary composition
  # is derived from files containing data in ascii format. Note the required
  # format of the input data: The first lines may contain any number of
  # comments if they begin with '#', but one of these lines needs to contain
  # the number of grid points in each dimension as for example '# POINTS: 3
  # 3'. The order of the data columns has to be 'x', 'composition1',
  # 'composition2', etc. in a 2d model and 'x', 'y', 'composition1',
  # 'composition2', etc., in a 3d model, according to the number of
  # compositional fields, which means that there has to be a single column for
  # every composition in the model. Note that the data in the input files need
  # to be sorted in a specific order: the first coordinate needs to ascend
  # first, followed by the second in order to assign the correct data to the
  # prescribed coordinates.If you use a spherical model, then the data will
  # still be handled as Cartesian, however the assumed grid changes. 'x' will
  # be replaced by the radial distance of the point to the bottom of the
  # model, 'y' by the azimuth angle and 'z' by the polar angle measured
  # positive from the north pole. The grid will be assumed to be a
  # latitude-longitude grid. Note that the order of spherical coordinates is
  # 'r', 'phi', 'theta' and not 'r', 'theta', 'phi', since this allows for
  # dimension independent expressions.
  # 
  # `box': A model in which the composition is chosen constant on all the
  # sides of a box.
  # 
  # `box with lithosphere boundary indicators': A model in which the
  # composition is chosen constant on all the sides of a box. Additional
  # boundary indicators are added to the lithospheric parts of the vertical
  # boundaries. This model is to be used with the 'Two Merged Boxes' Geometry
  # Model.
  # 
  # `initial composition': A model in which the composition at the boundary is
  # chosen to be the same as given in the initial conditions.
  # 
  # Because this class simply takes what the initial composition had
  # described, this class can not know certain pieces of information such as
  # the minimal and maximal composition on the boundary. For operations that
  # require this, for example in postprocessing, this boundary composition
  # model must therefore be told what the minimal and maximal values on the
  # boundary are. This is done using parameters set in section ``Boundary
  # composition model/Initial composition''.
  # 
  # `spherical constant': A model in which the composition is chosen constant
  # on the inner and outer boundaries of a spherical shell or chunk.
  # Parameters are read from subsection 'Spherical constant'.
  set Model name = unspecified


  subsection Ascii data model
    # The name of a directory that contains the model data. This path may
    # either be absolute (if starting with a '/') or relative to the current
    # directory. The path may also include the special text
    # '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the
    # ASPECT source files were located when ASPECT was compiled. This
    # interpretation allows, for example, to reference files located in the
    # 'data/' subdirectory of ASPECT.
    set Data directory             = $ASPECT_SOURCE_DIR/data/boundary-composition/ascii-data/test/

    # The file name of the material data. Provide file in format: (Velocity
    # file name).\%s\%d where \%s is a string specifying the boundary of the
    # model according to the names of the boundary indicators (of a box or a
    # spherical shell).\%d is any sprintf integer qualifier, specifying the
    # format of the current file number.
    set Data file name             = box_2d_%s.%d.txt

    # Time step between following velocity files. Depending on the setting of
    # the global 'Use years in output instead of seconds' flag in the input
    # file, this number is either interpreted as seconds or as years. The
    # default is one million, i.e., either one million seconds or one million
    # years.
    set Data file time step        = 1e6

    # In some cases the boundary files are not numbered in increasing but in
    # decreasing order (e.g. 'Ma BP'). If this flag is set to 'True' the
    # plugin will first load the file with the number 'First velocity file
    # number' and decrease the file number during the model run.
    set Decreasing file order      = false

    # Time from which on the velocity file with number 'First velocity file
    # number' is used as boundary condition. Previous to this time, a no-slip
    # boundary condition is assumed. Depending on the setting of the global
    # 'Use years in output instead of seconds' flag in the input file, this
    # number is either interpreted as seconds or as years.
    set First data file model time = 0

    # Number of the first velocity file to be loaded when the model time is
    # larger than 'First velocity file model time'.
    set First data file number     = 0

    # Scalar factor, which is applied to the boundary velocity. You might want
    # to use this to scale the velocities to a reference model (e.g. with
    # free-slip boundary) or another plate reconstruction. Another way to use
    # this factor is to convert units of the input files. The unit is assumed
    # to bem/s or m/yr depending on the 'Use years in output instead of
    # seconds' flag. If you provide velocities in cm/yr set this factor to
    # 0.01.
    set Scale factor               = 1
  end

  subsection Box
    # A comma separated list of composition boundary values at the bottom
    # boundary (at minimal y-value in 2d, or minimal z-value in 3d). This list
    # must have as many entries as there are compositional fields. Units:
    # none.
    set Bottom composition = 

    # A comma separated list of composition boundary values at the left
    # boundary (at minimal x-value). This list must have as many entries as
    # there are compositional fields. Units: none.
    set Left composition   = 

    # A comma separated list of composition boundary values at the right
    # boundary (at maximal x-value). This list must have as many entries as
    # there are compositional fields. Units: none.
    set Right composition  = 

    # A comma separated list of composition boundary values at the top
    # boundary (at maximal y-value in 2d, or maximal z-value in 3d). This list
    # must have as many entries as there are compositional fields. Units:
    # none.
    set Top composition    = 
  end

  subsection Box with lithosphere boundary indicators
    # A comma separated list of composition boundary values at the bottom
    # boundary (at minimal y-value in 2d, or minimal z-value in 3d). This list
    # must have as many entries as there are compositional fields. Units:
    # none.
    set Bottom composition            = 

    # A comma separated list of composition boundary values at the left
    # boundary (at minimal x-value). This list must have as many entries as
    # there are compositional fields. Units: none.
    set Left composition              = 

    # A comma separated list of composition boundary values at the left
    # boundary (at minimal x-value). This list must have as many entries as
    # there are compositional fields. Units: none.
    set Left composition lithosphere  = 

    # A comma separated list of composition boundary values at the right
    # boundary (at maximal x-value). This list must have as many entries as
    # there are compositional fields. Units: none.
    set Right composition             = 

    # A comma separated list of composition boundary values at the right
    # boundary (at maximal x-value). This list must have as many entries as
    # there are compositional fields. Units: none.
    set Right composition lithosphere = 

    # A comma separated list of composition boundary values at the top
    # boundary (at maximal y-value in 2d, or maximal z-value in 3d). This list
    # must have as many entries as there are compositional fields. Units:
    # none.
    set Top composition               = 
  end

  subsection Initial composition
    # Maximal composition. Units: none.
    set Maximal composition = 1

    # Minimal composition. Units: none.
    set Minimal composition = 0
  end

  subsection Spherical constant
    # Composition at the inner boundary (core mantle boundary). Units: none.
    set Inner composition = 1

    # Composition at the outer boundary (lithosphere water/air). Units: none.
    set Outer composition = 0
  end

end


subsection Boundary temperature model
  # Select one of the following models:
  # 
  # `ascii data': Implementation of a model in which the boundary data is
  # derived from files containing data in ascii format. Note the required
  # format of the input data: The first lines may contain any number of
  # comments if they begin with '#', but one of these lines needs to contain
  # the number of grid points in each dimension as for example '# POINTS: 3
  # 3'. The order of the data columns has to be 'x', 'Temperature [K]' in a 2d
  # model and  'x', 'y', 'Temperature [K]' in a 3d model, which means that
  # there has to be a single column containing the temperature. Note that the
  # data in the input files need to be sorted in a specific order: the first
  # coordinate needs to ascend first, followed by the second in order to
  # assign the correct data to the prescribed coordinates. If you use a
  # spherical model, then the data will still be handled as Cartesian, however
  # the assumed grid changes. 'x' will be replaced by the radial distance of
  # the point to the bottom of the model, 'y' by the azimuth angle and 'z' by
  # the polar angle measured positive from the north pole. The grid will be
  # assumed to be a latitude-longitude grid. Note that the order of spherical
  # coordinates is 'r', 'phi', 'theta' and not 'r', 'theta', 'phi', since this
  # allows for dimension independent expressions.
  # 
  # `box': A model in which the temperature is chosen constant on all the
  # sides of a box.
  # 
  # `box with lithosphere boundary indicators': A model in which the
  # temperature is chosen constant on all the sides of a box. Additional
  # boundary indicators are added to the lithospheric parts of the vertical
  # boundaries. This model is to be used with the 'Two Merged Boxes' Geometry
  # Model.
  # 
  # `constant': A model in which the temperature is chosen constant on a given
  # boundary indicator.  Parameters are read from the subsection 'Constant'.
  # 
  # `function': Implementation of a model in which the boundary temperature is
  # given in terms of an explicit formula that is elaborated in the parameters
  # in section ``Boundary temperature model|Function''.
  # 
  # Since the symbol $t$ indicating time may appear in the formulas for the
  # prescribed temperatures, it is interpreted as having units seconds unless
  # the global input parameter ``Use years in output instead of seconds'' is
  # set, in which case we interpret the formula expressions as having units
  # year.
  # 
  # Because this class simply takes what the function calculates, this class
  # can not know certain pieces of information such as the minimal and maximal
  # temperature on the boundary. For operations that require this, for example
  # in postprocessing, this boundary temperature model must therefore be told
  # what the minimal and maximal values on the boundary are. This is done
  # using parameters set in section ``Boundary temperature model/Initial
  # temperature''.
  # 
  # The format of these functions follows the syntax understood by the
  # muparser library, see Section~\ref{sec:muparser-format}.
  # 
  # `initial temperature': A model in which the temperature at the boundary is
  # chosen to be the same as given in the initial conditions.
  # 
  # Because this class simply takes what the initial temperature had
  # described, this class can not know certain pieces of information such as
  # the minimal and maximal temperature on the boundary. For operations that
  # require this, for example in postprocessing, this boundary temperature
  # model must therefore be told what the minimal and maximal values on the
  # boundary are. This is done using parameters set in section ``Boundary
  # temperature model/Initial temperature''.
  # 
  # `spherical constant': A model in which the temperature is chosen constant
  # on the inner and outer boundaries of a spherical shell, ellipsoidal chunk
  # or chunk. Parameters are read from subsection 'Spherical constant'.
  set Model name = box # default: unspecified


  subsection Ascii data model
    # The name of a directory that contains the model data. This path may
    # either be absolute (if starting with a '/') or relative to the current
    # directory. The path may also include the special text
    # '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the
    # ASPECT source files were located when ASPECT was compiled. This
    # interpretation allows, for example, to reference files located in the
    # 'data/' subdirectory of ASPECT.
    set Data directory             = $ASPECT_SOURCE_DIR/data/boundary-temperature/ascii-data/test/

    # The file name of the material data. Provide file in format: (Velocity
    # file name).\%s\%d where \%s is a string specifying the boundary of the
    # model according to the names of the boundary indicators (of a box or a
    # spherical shell).\%d is any sprintf integer qualifier, specifying the
    # format of the current file number.
    set Data file name             = box_2d_%s.%d.txt

    # Time step between following velocity files. Depending on the setting of
    # the global 'Use years in output instead of seconds' flag in the input
    # file, this number is either interpreted as seconds or as years. The
    # default is one million, i.e., either one million seconds or one million
    # years.
    set Data file time step        = 1e6

    # In some cases the boundary files are not numbered in increasing but in
    # decreasing order (e.g. 'Ma BP'). If this flag is set to 'True' the
    # plugin will first load the file with the number 'First velocity file
    # number' and decrease the file number during the model run.
    set Decreasing file order      = false

    # Time from which on the velocity file with number 'First velocity file
    # number' is used as boundary condition. Previous to this time, a no-slip
    # boundary condition is assumed. Depending on the setting of the global
    # 'Use years in output instead of seconds' flag in the input file, this
    # number is either interpreted as seconds or as years.
    set First data file model time = 0

    # Number of the first velocity file to be loaded when the model time is
    # larger than 'First velocity file model time'.
    set First data file number     = 0

    # Scalar factor, which is applied to the boundary velocity. You might want
    # to use this to scale the velocities to a reference model (e.g. with
    # free-slip boundary) or another plate reconstruction. Another way to use
    # this factor is to convert units of the input files. The unit is assumed
    # to bem/s or m/yr depending on the 'Use years in output instead of
    # seconds' flag. If you provide velocities in cm/yr set this factor to
    # 0.01.
    set Scale factor               = 1
  end

  subsection Box
    # Temperature at the bottom boundary (at minimal z-value). Units: K.
    set Bottom temperature = 1 # default: 0

    # Temperature at the left boundary (at minimal x-value). Units: K.
    set Left temperature   = 1

    # Temperature at the right boundary (at maximal x-value). Units: K.
    set Right temperature  = 0

    # Temperature at the top boundary (at maximal x-value). Units: K.
    set Top temperature    = 0
  end

  subsection Box with lithosphere boundary indicators
    # Temperature at the bottom boundary (at minimal z-value). Units: K.
    set Bottom temperature            = 0

    # Temperature at the left boundary (at minimal x-value). Units: K.
    set Left temperature              = 1

    # Temperature at the additional left lithosphere boundary (specified by
    # user in Geometry Model). Units: K.
    set Left temperature lithosphere  = 0

    # Temperature at the right boundary (at maximal x-value). Units: K.
    set Right temperature             = 0

    # Temperature at the additional right lithosphere boundary (specified by
    # user in Geometry Model). Units: K.
    set Right temperature lithosphere = 0

    # Temperature at the top boundary (at maximal x-value). Units: K.
    set Top temperature               = 0
  end

  subsection Constant
    # A comma separated list of mappings between boundary indicators and the
    # temperature associated with the boundary indicators. The format for this
    # list is ``indicator1 : value1, indicator2 : value2, ...'', where each
    # indicator is a valid boundary indicator (either a number or the symbolic
    # name of a boundary as provided by the geometry model) and each value is
    # the temperature of that boundary.
    set Boundary indicator to temperature mappings = 
  end

  subsection Function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0

    # Maximal temperature. Units: K.
    set Maximal temperature = 3773

    # Minimal temperature. Units: K.
    set Minimal temperature = 273

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,t
  end

  subsection Initial temperature
    # Maximal temperature. Units: K.
    set Maximal temperature = 3773

    # Minimal temperature. Units: K.
    set Minimal temperature = 0
  end

  subsection Spherical constant
    # Temperature at the inner boundary (core mantle boundary). Units: K.
    set Inner temperature = 6000

    # Temperature at the outer boundary (lithosphere water/air). Units: K.
    set Outer temperature = 0
  end

end


subsection Boundary traction model
  subsection Function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0; 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,t
  end

end


subsection Boundary velocity model
  subsection Ascii data model
    # The name of a directory that contains the model data. This path may
    # either be absolute (if starting with a '/') or relative to the current
    # directory. The path may also include the special text
    # '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the
    # ASPECT source files were located when ASPECT was compiled. This
    # interpretation allows, for example, to reference files located in the
    # 'data/' subdirectory of ASPECT.
    set Data directory             = $ASPECT_SOURCE_DIR/data/velocity-boundary-conditions/ascii-data/test/

    # The file name of the material data. Provide file in format: (Velocity
    # file name).\%s\%d where \%s is a string specifying the boundary of the
    # model according to the names of the boundary indicators (of a box or a
    # spherical shell).\%d is any sprintf integer qualifier, specifying the
    # format of the current file number.
    set Data file name             = box_2d_%s.%d.txt

    # Time step between following velocity files. Depending on the setting of
    # the global 'Use years in output instead of seconds' flag in the input
    # file, this number is either interpreted as seconds or as years. The
    # default is one million, i.e., either one million seconds or one million
    # years.
    set Data file time step        = 1e6

    # In some cases the boundary files are not numbered in increasing but in
    # decreasing order (e.g. 'Ma BP'). If this flag is set to 'True' the
    # plugin will first load the file with the number 'First velocity file
    # number' and decrease the file number during the model run.
    set Decreasing file order      = false

    # Time from which on the velocity file with number 'First velocity file
    # number' is used as boundary condition. Previous to this time, a no-slip
    # boundary condition is assumed. Depending on the setting of the global
    # 'Use years in output instead of seconds' flag in the input file, this
    # number is either interpreted as seconds or as years.
    set First data file model time = 0

    # Number of the first velocity file to be loaded when the model time is
    # larger than 'First velocity file model time'.
    set First data file number     = 0

    # Scalar factor, which is applied to the boundary velocity. You might want
    # to use this to scale the velocities to a reference model (e.g. with
    # free-slip boundary) or another plate reconstruction. Another way to use
    # this factor is to convert units of the input files. The unit is assumed
    # to bem/s or m/yr depending on the 'Use years in output instead of
    # seconds' flag. If you provide velocities in cm/yr set this factor to
    # 0.01.
    set Scale factor               = 1
  end

  subsection Function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = pi=3.1415926                    # default: 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = if(x>1+sin(0.5*pi*t), 1, -1); 0 # default: 0; 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,z,t                           # default: x,y,t
  end

  subsection GPlates model
    # The name of a directory that contains the model data. This path may
    # either be absolute (if starting with a '/') or relative to the current
    # directory. The path may also include the special text
    # '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the
    # ASPECT source files were located when ASPECT was compiled. This
    # interpretation allows, for example, to reference files located in the
    # 'data/' subdirectory of ASPECT.
    set Data directory             = $ASPECT_SOURCE_DIR/data/velocity-boundary-conditions/gplates/

    # Time step between following velocity files. Depending on the setting of
    # the global 'Use years in output instead of seconds' flag in the input
    # file, this number is either interpreted as seconds or as years. The
    # default is one million, i.e., either one million seconds or one million
    # years.
    set Data file time step        = 1e6

    # In some cases the boundary files are not numbered in increasing but in
    # decreasing order (e.g. 'Ma BP'). If this flag is set to 'True' the
    # plugin will first load the file with the number 'First velocity file
    # number' and decrease the file number during the model run.
    set Decreasing file order      = false

    # Time from which on the velocity file with number 'First velocity file
    # number' is used as boundary condition. Previous to this time, a no-slip
    # boundary condition is assumed. Depending on the setting of the global
    # 'Use years in output instead of seconds' flag in the input file, this
    # number is either interpreted as seconds or as years.
    set First data file model time = 0

    # Number of the first velocity file to be loaded when the model time is
    # larger than 'First velocity file model time'.
    set First data file number     = 0

    # Determines the depth of the lithosphere, so that the GPlates velocities
    # can be applied at the sides of the model as well as at the surface.
    set Lithosphere thickness      = 100000

    # Point that determines the plane in which a 2D model lies in. Has to be
    # in the format 'a,b' where a and b are theta (polar angle)  and phi in
    # radians.
    set Point one                  = 1.570796,0.0

    # Point that determines the plane in which a 2D model lies in. Has to be
    # in the format 'a,b' where a and b are theta (polar angle)  and phi in
    # radians.
    set Point two                  = 1.570796,1.570796

    # Scalar factor, which is applied to the boundary velocity. You might want
    # to use this to scale the velocities to a reference model (e.g. with
    # free-slip boundary) or another plate reconstruction.
    set Scale factor               = 1

    # The file name of the material data. Provide file in format: (Velocity
    # file name).\%d.gpml where \%d is any sprintf integer qualifier,
    # specifying the format of the current file number.
    set Velocity file name         = phi.%d
  end

end


subsection Checkpointing
  # The number of timesteps between performing checkpoints. If 0 and time
  # between checkpoint is not specified, checkpointing will not be performed.
  # Units: None.
  set Steps between checkpoint = 0

  # The wall time between performing checkpoints. If 0, will use the
  # checkpoint step frequency instead. Units: Seconds.
  set Time between checkpoint  = 0
end


subsection Compositional fields
  # A list of integers smaller than or equal to the number of compositional
  # fields. All compositional fields in this list will be normalized before
  # the first timestep. The normalization is implemented in the following way:
  # First, the sum of the fields to be normalized is calculated at every point
  # and the global maximum is determined. Second, the compositional fields to
  # be normalized are divided by this maximum.
  set List of normalized fields = 

  # A user-defined name for each of the compositional fields requested.
  set Names of fields           = 

  # The number of fields that will be advected along with the flow field,
  # excluding velocity, pressure and temperature.
  set Number of fields          = 2 # default: 0
end


subsection Compositional initial conditions
  # Select one of the following models:
  # 
  # `ascii data': Implementation of a model in which the initial composition
  # is derived from files containing data in ascii format. Note the required
  # format of the input data: The first lines may contain any number of
  # comments if they begin with '#', but one of these lines needs to contain
  # the number of grid points in each dimension as for example '# POINTS: 3
  # 3'. The order of the data columns has to be 'x', 'y', 'composition1',
  # 'composition2', etc. in a 2d model and 'x', 'y', 'z', 'composition1',
  # 'composition2', etc. in a 3d model, according to the number of
  # compositional fields, which means that there has to be a single column for
  # every composition in the model.Note that the data in the input files need
  # to be sorted in a specific order: the first coordinate needs to ascend
  # first, followed by the second and the third at last in order to assign the
  # correct data to the prescribed coordinates. If you use a spherical model,
  # then the data will still be handled as Cartesian, however the assumed grid
  # changes. 'x' will be replaced by the radial distance of the point to the
  # bottom of the model, 'y' by the azimuth angle and 'z' by the polar angle
  # measured positive from the north pole. The grid will be assumed to be a
  # latitude-longitude grid. Note that the order of spherical coordinates is
  # 'r', 'phi', 'theta' and not 'r', 'theta', 'phi', since this allows for
  # dimension independent expressions.
  # 
  # `function': Specify the composition in terms of an explicit formula. The
  # format of these functions follows the syntax understood by the muparser
  # library, see Section~\ref{sec:muparser-format}.
  set Model name = function


  subsection Ascii data model
    # The name of a directory that contains the model data. This path may
    # either be absolute (if starting with a '/') or relative to the current
    # directory. The path may also include the special text
    # '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the
    # ASPECT source files were located when ASPECT was compiled. This
    # interpretation allows, for example, to reference files located in the
    # 'data/' subdirectory of ASPECT.
    set Data directory = $ASPECT_SOURCE_DIR/data/compositional-initial-conditions/ascii-data/test/

    # The file name of the material data. Provide file in format: (Velocity
    # file name).\%s\%d where \%s is a string specifying the boundary of the
    # model according to the names of the boundary indicators (of a box or a
    # spherical shell).\%d is any sprintf integer qualifier, specifying the
    # format of the current file number.
    set Data file name = box_2d.txt

    # Scalar factor, which is applied to the boundary velocity. You might want
    # to use this to scale the velocities to a reference model (e.g. with
    # free-slip boundary) or another plate reconstruction. Another way to use
    # this factor is to convert units of the input files. The unit is assumed
    # to bem/s or m/yr depending on the 'Use years in output instead of
    # seconds' flag. If you provide velocities in cm/yr set this factor to
    # 0.01.
    set Scale factor   = 1
  end

  subsection Function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = if(y<0.2, 1, 0) ; if(y>0.8, 1, 0) # default: 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y                               # default: x,y,t
  end

end


subsection Discretization
  # The polynomial degree to use for the composition variable(s). Units:
  # None.
  set Composition polynomial degree                = 2

  # The polynomial degree to use for the velocity variables in the Stokes
  # system. The polynomial degree for the pressure variable will then be one
  # less in order to make the velocity/pressure pair conform with the usual
  # LBB (Babuska-Brezzi) condition. In other words, we are using a Taylor-Hood
  # element for the Stoeks equations and this parameter indicates the
  # polynomial degree of it. Units: None.
  set Stokes velocity polynomial degree            = 2

  # The polynomial degree to use for the temperature variable. Units: None.
  set Temperature polynomial degree                = 2

  # Whether to use a composition discretization that is discontinuous as
  # opposed to continuous. This then requires the assembly of face terms
  # between cells, and weak imposition of boundary terms for the composition
  # field via the discontinuous Galerkin method.
  set Use discontinuous composition discretization = true  # default: false

  # Whether to use a temperature discretization that is discontinuous as
  # opposed to continuous. This then requires the assembly of face terms
  # between cells, and weak imposition of boundary terms for the temperature
  # field via the interior-penalty discontinuous Galerkin method.
  set Use discontinuous temperature discretization = false

  # Whether to apply the limiter as a postprocess after obtain the
  # discontinous solution
  set Use limiter for discontinuous solution       = true  # default: false

  # Whether to use a Stokes discretization that is locally conservative at the
  # expense of a larger number of degrees of freedom (true), or to go with a
  # cheaper discretization that does not locally conserve mass, although it is
  # globally conservative (false).
  # 
  # When using a locally conservative discretization, the finite element space
  # for the pressure is discontinuous between cells and is the polynomial
  # space $P_ {-q}$ of polynomials of degree $q$ in each variable separately.
  # Here, $q$ is one less than the value given in the parameter ``Stokes
  # velocity polynomial degree''. As a consequence of choosing this element,
  # it can be shown if the medium is considered incompressible that the
  # computed discrete velocity field $\mathbf u_h$ satisfies the property
  # $\int_ {\partial K} \mathbf u_h \cdot \mathbf n = 0$ for every cell $K$,
  # i.e., for each cell inflow and outflow exactly balance each other as one
  # would expect for an incompressible medium. In other words, the velocity
  # field is locally conservative.
  # 
  # On the other hand, if this parameter is set to ``false'', then the finite
  # element space is chosen as $Q_q$. This choice does not yield the local
  # conservation property but has the advantage of requiring fewer degrees of
  # freedom. Furthermore, the error is generally smaller with this choice.
  # 
  # For an in-depth discussion of these issues and a quantitative evaluation
  # of the different choices, see \cite {KHB12} .
  set Use locally conservative discretization      = false


  subsection Stabilization parameters
    # The value used to penalize discontinuities in the discontinuous Galerkin
    # method. This is used only for the temperature field, and not for the
    # composition field, as pure advection does not use the interior penalty
    # method. This is largely empirically decided -- it must be large enough
    # to ensure the bilinear form is coercive, but not so large as to penalize
    # discontinuity at all costs.
    set Discontinuous penalty              = 10

    # If set to false, the artificial viscosity of a cell is computed andis
    # computed on every cell separately as discussed in \cite{KHB12}. If set
    # to true, the maximum of the artificial viscosity in the cell as well as
    # the neighbors of the cell is computed and used instead.
    set Use artificial viscosity smoothing = false

    # The exponent $\alpha$ in the entropy viscosity stabilization. Valid
    # options are 1 or 2. The recommended setting is 2. (This parameter does
    # not correspond to any variable in the 2012 GJI paper by Kronbichler,
    # Heister and Bangerth that describes ASPECT. Rather, the paper always
    # uses 2 as the exponent in the definition of the entropy, following eq.
    # (15).).Units: None.
    set alpha                              = 2

    # The $\beta$ factor in the artificial viscosity stabilization. An
    # appropriate value for 2d is 0.078 and 0.117 for 3d. (For historical
    # reasons, the name used here is different from the one used in the 2012
    # GJI paper by Kronbichler, Heister and Bangerth that describes ASPECT.
    # This parameter corresponds to the factor $\alpha_\text {max}$ in the
    # formulas following equation (15) of the paper. After further
    # experiments, we have also chosen to use a different value than described
    # there: It can be chosen as stated there for uniformly refined meshes,
    # but it needs to be chosen larger if the mesh has cells that are not
    # squares or cubes.) Units: None.
    set beta                               = 0.078

    # The $c_R$ factor in the entropy viscosity stabilization. (For historical
    # reasons, the name used here is different from the one used in the 2012
    # GJI paper by Kronbichler, Heister and Bangerth that describes ASPECT.
    # This parameter corresponds to the factor $\alpha_E$ in the formulas
    # following equation (15) of the paper. After further experiments, we have
    # also chosen to use a different value than described there.) Units:
    # None.
    set cR                                 = 0.33
  end

end


subsection Free surface
  # A comma separated list of names denoting those boundaries where there the
  # mesh is allowed to move tangential to the boundary. All tangential mesh
  # movements along those boundaries that have tangential material velocity
  # boundary conditions are allowed by default, this parameters allows to
  # generate mesh movements along other boundaries that are open, or have
  # prescribed material velocities or tractions.
  # 
  # The names of the boundaries listed here can either be numbers (in which
  # case they correspond to the numerical boundary indicators assigned by the
  # geometry object), or they can correspond to any of the symbolic names the
  # geometry object may have provided for each part of the boundary. You may
  # want to compare this with the documentation of the geometry model you use
  # in your model.
  set Additional tangential mesh velocity boundary indicators = 

  # Theta parameter described in Kaus et. al. 2010. An unstabilized free
  # surface can overshoot its equilibrium position quite easily and generate
  # unphysical results.  One solution is to use a quasi-implicit correction
  # term to the forces near the free surface.  This parameter describes how
  # much the free surface is stabilized with this term, where zero is no
  # stabilization, and one is fully implicit.
  set Free surface stabilization theta                        = 0.5

  # After each time step the free surface must be advected in the direction of
  # the velocity field. Mass conservation requires that the mesh velocity is
  # in the normal direction of the surface. However, for steep topography or
  # large curvature, advection in the normal direction can become
  # ill-conditioned, and instabilities in the mesh can form. Projection of the
  # mesh velocity onto the local vertical direction can preserve the mesh
  # quality better, but at the cost of slightly poorer mass conservation of
  # the domain.
  set Surface velocity projection                             = normal
end


subsection Geometry model
  # Select one of the following models:
  # 
  # `box': A box geometry parallel to the coordinate directions. The extent of
  # the box in each coordinate direction is set in the parameter file. The box
  # geometry labels its 2*dim sides as follows: in 2d, boundary indicators 0
  # through 3 denote the left, right, bottom and top boundaries; in 3d,
  # boundary indicators 0 through 5 indicate left, right, front, back, bottom
  # and top boundaries (see also the documentation of the deal.II class
  # ``GeometryInfo''). You can also use symbolic names ``left'', ``right'',
  # etc., to refer to these boundaries in input files.
  # 
  # `box with lithosphere boundary indicators': A box geometry parallel to the
  # coordinate directions. The extent of the box in each coordinate direction
  # is set in the parameter file. This geometry model labels its sides with
  # 2*dim+2*(dim-1) boundary indicators: in 2d, boundary indicators 0 through
  # 3 denote the left, right, bottom and top boundaries, while indicators4 and
  # 5 denote the upper part of the left and right vertical boundary,
  # respectively. In 3d, boundary indicators 0 through 5 indicate left, right,
  # front, back, bottom and top boundaries (see also the documentation of the
  # deal.II class ``GeometryInfo''), while indicators 6, 7, 8 and 9 denote the
  # left, rigth, front and back upper parts of the vertical boundaries,
  # respectively. You can also use symbolic names ``left'', ``right'', ``left
  # lithosphere'', etc., to refer to these boundaries in input files.
  # 
  # Note that for a given ``Global refinement level'' and no user-specified
  # ``Repetitions'', the lithosphere part of the mesh will be more refined.
  # 
  # The additional boundary indicators for the lithosphere allow for selecting
  # boundary conditions for the lithosphere different from those for the
  # underlying mantle. An example application of this geometry is to prescribe
  # a velocity on the lithospheric plates, but use open boundary conditions
  # underneath.
  # 
  # `chunk': A geometry which can be described as a chunk of a spherical
  # shell, bounded by lines of longitude, latitude and radius. The minimum and
  # maximum longitude, (latitude) and depth of the chunk is set in the
  # parameter file. The chunk geometry labels its 2*dim sides as follows:
  # ``west'' and ``east'': minimum and maximum longitude, ``south'' and
  # ``north'': minimum and maximum latitude, ``inner'' and ``outer'': minimum
  # and maximum radii. Names in the parameter files are as follows: Chunk
  # (minimum || maximum) (longitude || latitude): edges of geographical
  # quadrangle (in degrees)Chunk (inner || outer) radius: Radii at bottom and
  # top of chunk(Longitude || Latitude || Radius) repetitions: number of cells
  # in each coordinate direction.
  # 
  # `ellipsoidal chunk': A 3D chunk geometry that accounts for Earth's
  # ellipticity (default assuming the WGS84 ellipsoid definition) which can be
  # defined in non-coordinate directions. In the description of the
  # ellipsoidal chunk, two of the ellipsoidal axes have the same length so
  # that there is only a semi-major axis and a semi-minor axis. The user has
  # two options for creating an ellipsoidal chunk geometry: 1) by defining two
  # opposing points (SW and NE or NW and SE) a coordinate parallel ellipsoidal
  # chunk geometry will be created. 2) by defining three points a
  # non-coordinate parallel ellipsoidal chunk will be created. The points are
  # defined in the input file by longitude:latitude. It is also possible to
  # define additional subdivisions of the mesh in each direction. Faces of the
  # model are defined as 0, west; 1,east; 2, south; 3, north; 4, inner; 5,
  # outer.
  # 
  # `sphere': Geometry model for sphere with a user specified radius. This
  # geometry has only a single boundary, so the only valid boundary indicator
  # to specify in the input file is ``0''. It can also be referenced by the
  # symbolic name ``surface'' in input files.
  # 
  # `spherical shell': A geometry representing a spherical shell or a piece of
  # it. Inner and outer radii are read from the parameter file in subsection
  # 'Spherical shell'.
  # 
  # The model assigns boundary indicators as follows: In 2d, inner and outer
  # boundaries get boundary indicators zero and one, and if the opening angle
  # set in the input file is less than 360, then left and right boundaries are
  # assigned indicators two and three. These boundaries can also be referenced
  # using the symbolic names 'inner', 'outer' and (if applicable) 'left',
  # 'right'.
  # 
  # In 3d, inner and outer indicators are treated as in 2d. If the opening
  # angle is chosen as 90 degrees, i.e., the domain is the intersection of a
  # spherical shell and the first octant, then indicator 2 is at the face
  # $x=0$, 3 at $y=0$, and 4 at $z=0$. These last three boundaries can then
  # also be referred to as 'east', 'west' and 'south' symbolically in input
  # files.
  set Model name = box # default: unspecified


  subsection Box
    # X coordinate of box origin. Units: m.
    set Box origin X coordinate = 0

    # Y coordinate of box origin. Units: m.
    set Box origin Y coordinate = 0

    # Z coordinate of box origin. This value is ignored if the simulation is
    # in 2d. Units: m.
    set Box origin Z coordinate = 0

    # Extent of the box in x-direction. Units: m.
    set X extent                = 2     # default: 1

    # Whether the box should be periodic in X direction
    set X periodic              = false

    # Number of cells in X direction.
    set X repetitions           = 1

    # Extent of the box in y-direction. Units: m.
    set Y extent                = 1

    # Whether the box should be periodic in Y direction
    set Y periodic              = false

    # Number of cells in Y direction.
    set Y repetitions           = 1

    # Extent of the box in z-direction. This value is ignored if the
    # simulation is in 2d. Units: m.
    set Z extent                = 1

    # Whether the box should be periodic in Z direction
    set Z periodic              = false

    # Number of cells in Z direction.
    set Z repetitions           = 1
  end

  subsection Box with lithosphere boundary indicators
    # X coordinate of box origin. Units: m.
    set Box origin X coordinate   = 0

    # Y coordinate of box origin. Units: m.
    set Box origin Y coordinate   = 0

    # Z coordinate of box origin. This value is ignored if the simulation is
    # in 2d. Units: m.
    set Box origin Z coordinate   = 0

    # The thickness of the lithosphere used to create additional boundary
    # indicators to set specific boundary conditions for the lithosphere.
    set Lithospheric thickness    = 0.2

    # Extent of the box in x-direction. Units: m.
    set X extent                  = 1

    # Whether the box should be periodic in X direction.
    set X periodic                = false

    # Whether the box should be periodic in X direction in the lithosphere.
    set X periodic lithosphere    = false

    # Number of cells in X direction of the lower box. The same number of
    # repetitions will be used in the upper box.
    set X repetitions             = 1

    # Extent of the box in y-direction. Units: m.
    set Y extent                  = 1

    # Whether the box should be periodic in Y direction.
    set Y periodic                = false

    # Whether the box should be periodic in Y direction in the lithosphere.
    # This value is ignored if the simulation is in 2d.
    set Y periodic lithosphere    = false

    # Number of cells in Y direction of the lower box. If the simulation is in
    # 3d, the same number of repetitions will be used in the upper box.
    set Y repetitions             = 1

    # Number of cells in Y direction in the lithosphere. This value is ignored
    # if the simulation is in 3d.
    set Y repetitions lithosphere = 1

    # Extent of the box in z-direction. This value is ignored if the
    # simulation is in 2d. Units: m.
    set Z extent                  = 1

    # Whether the box should be periodic in Z direction. This value is ignored
    # if the simulation is in 2d.
    set Z periodic                = false

    # Number of cells in Z direction of the lower box. This value is ignored
    # if the simulation is in 2d.
    set Z repetitions             = 1

    # Number of cells in Z direction in the lithosphere. This value is ignored
    # if the simulation is in 2d.
    set Z repetitions lithosphere = 1
  end

  subsection Chunk
    # Radius at the bottom surface of the chunk. Units: m.
    set Chunk inner radius      = 0

    # Maximum latitude of the chunk. This value is ignored if the simulation
    # is in 2d. Units: degrees.
    set Chunk maximum latitude  = 1

    # Maximum longitude of the chunk. Units: degrees.
    set Chunk maximum longitude = 1

    # Minimum latitude of the chunk. This value is ignored if the simulation
    # is in 2d. Units: degrees.
    set Chunk minimum latitude  = 0

    # Minimum longitude of the chunk. Units: degrees.
    set Chunk minimum longitude = 0

    # Radius at the top surface of the chunk. Units: m.
    set Chunk outer radius      = 1

    # Number of cells in latitude. This value is ignored if the simulation is
    # in 2d
    set Latitude repetitions    = 1

    # Number of cells in longitude.
    set Longitude repetitions   = 1

    # Number of cells in radius.
    set Radius repetitions      = 1
  end

  subsection Ellipsoidal chunk
    # Bottom depth of model region.
    set Depth                    = 500000.0

    # The number of subdivisions of the coarse (initial) mesh in depth.
    set Depth subdivisions       = 1

    # The number of subdivisions of the coarse (initial) mesh in the East-West
    # direction.
    set East-West subdivisions   = 1

    # Eccentricity of the ellipsoid. Zero is a perfect sphere, default
    # (8.1819190842622e-2) is WGS84.
    set Eccentricity             = 8.1819190842622e-2

    # Longitude:latitude in degrees of the North-East corner point of model
    # region.The North-East direction is positive. If one of the three corners
    # is not providedthe missing corner value will be calculated so all faces
    # are parallel.
    set NE corner                = 

    # Longitude:latitude in degrees of the North-West corner point of model
    # region. The North-East direction is positive. If one of the three
    # corners is not providedthe missing corner value will be calculated so
    # all faces are parallel.
    set NW corner                = 

    # The number of subdivisions of the coarse (initial) mesh in the
    # North-South direction.
    set North-South subdivisions = 1

    # Longitude:latitude in degrees of the South-East corner point of model
    # region. The North-East direction is positive. If one of the three
    # corners is not providedthe missing corner value will be calculated so
    # all faces are parallel.
    set SE corner                = 

    # Longitude:latitude in degrees of the South-West corner point of model
    # region. The North-East direction is positive. If one of the three
    # corners is not providedthe missing corner value will be calculated so
    # all faces are parallel.
    set SW corner                = 

    # The semi-major axis (a) of an ellipsoid. This is the radius for a sphere
    # (eccentricity=0). Default WGS84 semi-major axis.
    set Semi-major axis          = 6378137.0
  end

  subsection Sphere
    # Radius of the sphere. Units: m.
    set Radius = 6371000
  end

  subsection Spherical shell
    # The number of cells in circumferential direction that are created in the
    # coarse mesh in 2d. If zero, this number is chosen automatically in a way
    # that produces meshes in which cells have a reasonable aspect ratio for
    # models in which the depth of the mantle is roughly that of the Earth.
    # For planets with much shallower mantles and larger cores, you may want
    # to chose a larger number to avoid cells that are elongated in tangential
    # and compressed in radial direction.
    # 
    # In 3d, the number of cells is computed differently and does not have an
    # easy interpretation. Valid values for this parameter in 3d are 0 (let
    # this class choose), 6, 12 and 96. Other possible values may be discussed
    # in the documentation of the deal.II function GridGenerator::hyper_shell.
    # The parameter is best left at its default in 3d.
    # 
    # In either case, this parameter is ignored unless the opening angle of
    # the domain is 360 degrees.
    set Cells along circumference = 0

    # Inner radius of the spherical shell. Units: m.
    set Inner radius              = 3481000

    # Opening angle in degrees of the section of the shell that we want to
    # build. Units: degrees.
    set Opening angle             = 360

    # Outer radius of the spherical shell. Units: m.
    set Outer radius              = 6336000
  end

end


subsection Gravity model
  # Select one of the following models:
  # 
  # `function': Gravity is given in terms of an explicit formula that is
  # elaborated in the parameters in section ``Gravity model|Function''. The
  # format of these functions follows the syntax understood by the muparser
  # library, see Section~\ref{sec:muparser-format}.
  # 
  # `radial constant': A gravity model in which the gravity direction is
  # radially inward and at constant magnitude. The magnitude is read from the
  # parameter file in subsection 'Radial constant'.
  # 
  # `radial earth-like': A gravity model in which the gravity direction is
  # radially inward and with a magnitude that matches that of the earth at the
  # core-mantle boundary as well as at the surface and in between is
  # physically correct under the assumption of a constant density.
  # 
  # `radial linear': A gravity model which is radially inward, where the
  # magnitudedecreases linearly with depth down to zero at the maximal depth
  # the geometry returns, as you would get with a constantdensity spherical
  # domain. (Note that this would be for a full sphere, not a spherical
  # shell.) The magnitude of gravity at the surface is read from the input
  # file in a section ``Gravity model/Radial linear''.
  # 
  # `vertical': A gravity model in which the gravity direction is vertically
  # downward and at a constant magnitude by default equal to one.
  set Model name = vertical # default: unspecified


  subsection Function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0; 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,t
  end

  subsection Radial constant
    # Magnitude of the gravity vector in $m/s^2$. The direction is always
    # radially inward towards the center of the earth.
    set Magnitude = 9.81
  end

  subsection Radial linear
    # Magnitude of the radial gravity vector at the surface of the domain.
    # Units: $m/s^2$
    set Magnitude at surface = 9.8
  end

  subsection Vertical
    # Value of the gravity vector in $m/s^2$ directed along negative y (2D) or
    # z (3D) axis.
    set Magnitude = 1
  end

end


subsection Heating model
  # A comma separated list of heating models that will be used to calculate
  # the heating terms in the energyequation. The results of each of these
  # criteria , i.e., the heating source terms and the latent heat terms for
  # theleft hand side will be added.
  # 
  # The following heating models are available:
  # 
  # `adiabatic heating': Implementation of a standard and a simplified model
  # ofadiabatic heating.
  # 
  # `constant heating': Implementation of a model in which the heating rate is
  # constant.
  # 
  # `function': Implementation of a model in which the heating rate is given
  # in terms of an explicit formula that is elaborated in the parameters in
  # section ``Heating model|Function''. The format of these functions follows
  # the syntax understood by the muparser library, see
  # Section~\ref{sec:muparser-format}.
  # 
  # The formula is interpreted as having units W/kg.
  # 
  # Since the symbol $t$ indicating time may appear in the formulas for the
  # heating rate, it is interpreted as having units seconds unless the global
  # parameter ``Use years in output instead of seconds'' is set.
  # 
  # `latent heat': Implementation of a standard model for latent heat.
  # 
  # `radioactive decay': Implementation of a model in which the internal
  # heating rate is radioactive decaying in the following rule:
  # \[(\text{initial concentration})\cdot 0.5^{\text{time}/(\text{half
  # life})}\]
  # The crust and mantle can have different concentrations, and the crust can
  # be defined either by depth or by a certain compositional field.
  # The formula is interpreted as having units W/kg.
  # 
  # `shear heating': Implementation of a standard model for shear heating.
  set List of model names = 

  # Select one of the following models:
  # 
  # Warning: This is the old formulation of specifying heating models and
  # shouldn't be used. Please use 'List ofmodel names' instead.`adiabatic
  # heating': Implementation of a standard and a simplified model ofadiabatic
  # heating.
  # 
  # `constant heating': Implementation of a model in which the heating rate is
  # constant.
  # 
  # `function': Implementation of a model in which the heating rate is given
  # in terms of an explicit formula that is elaborated in the parameters in
  # section ``Heating model|Function''. The format of these functions follows
  # the syntax understood by the muparser library, see
  # Section~\ref{sec:muparser-format}.
  # 
  # The formula is interpreted as having units W/kg.
  # 
  # Since the symbol $t$ indicating time may appear in the formulas for the
  # heating rate, it is interpreted as having units seconds unless the global
  # parameter ``Use years in output instead of seconds'' is set.
  # 
  # `latent heat': Implementation of a standard model for latent heat.
  # 
  # `radioactive decay': Implementation of a model in which the internal
  # heating rate is radioactive decaying in the following rule:
  # \[(\text{initial concentration})\cdot 0.5^{\text{time}/(\text{half
  # life})}\]
  # The crust and mantle can have different concentrations, and the crust can
  # be defined either by depth or by a certain compositional field.
  # The formula is interpreted as having units W/kg.
  # 
  # `shear heating': Implementation of a standard model for shear heating.
  set Model name          = unspecified


  subsection Adiabatic heating
    # A flag indicating whether the adiabatic heating should be simplified
    # from $\alpha T (\mathbf u \cdot \nabla p)$ to $ \alpha \rho T (\mathbf u
    # \cdot \mathbf g) $.
    set Use simplified adiabatic heating = false
  end

  subsection Constant heating
    # The specific rate of heating due to radioactive decay (or other bulk
    # sources you may want to describe). This parameter corresponds to the
    # variable $H$ in the temperature equation stated in the manual, and the
    # heating term is $ho H$. Units: W/kg.
    set Radiogenic heating rate = 0e0
  end

  subsection Function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,t
  end

  subsection Latent heat
  end

  subsection Radioactive decay
    # Which composition field should be treated as crust
    set Crust composition number      = 0

    # Whether crust defined by composition or depth
    set Crust defined by composition  = false

    # Depth of the crust when crust if defined by depth. Units: m
    set Crust depth                   = 0

    # Half decay times. Units: (Seconds), or (Years) if set 'use years instead
    # of seconds'.
    set Half decay times              = 

    # Heating rates of different elements (W/kg)
    set Heating rates                 = 

    # Initial concentrations of different elements (ppm)
    set Initial concentrations crust  = 

    # Initial concentrations of different elements (ppm)
    set Initial concentrations mantle = 

    # Number of radioactive elements
    set Number of elements            = 0
  end

  subsection Shear heating
  end

end


subsection Initial conditions
  # Select one of the following models:
  # 
  # `S40RTS perturbation': An initial temperature field in which the
  # temperature is perturbed following the S20RTS or S40RTS shear wave
  # velocity model by Ritsema and others, which can be downloaded here
  # \url{http://www.earth.lsa.umich.edu/~jritsema/research.html}. Information
  # on the vs model can be found in Ritsema, J., Deuss, A., van Heijst, H.J.
  # \& Woodhouse, J.H., 2011. S40RTS: a degree-40 shear-velocity model for the
  # mantle from new Rayleigh wave dispersion, teleseismic traveltime and
  # normal-mode splitting function measurements, Geophys. J. Int. 184,
  # 1223-1236. The scaling between the shear wave perturbation and the
  # temperature perturbation can be set by the user with the 'vs to density
  # scaling' parameter and the 'Thermal expansion coefficient in initial
  # temperature scaling' parameter. The scaling is as follows: $\delta ln \rho
  # (r,\theta,\phi) = \xi \cdot \delta ln v_s(r,\theta, \phi)$ and $\delta
  # T(r,\theta,\phi) = - \frac{1}{\alpha} \delta ln \rho(r,\theta,\phi)$.
  # $\xi$ is the 'vs to density scaling' parameter and $\alpha$ is the
  # 'Thermal expansion coefficient in initial temperature scaling' parameter.
  # The temperature perturbation is added to an otherwise constant temperature
  # (incompressible model) or adiabatic reference profile (compressible
  # model). If a depth is specified in 'Remove temperature heterogeneity down
  # to specified depth', there is no temperature perturbation prescribed down
  # to that depth.
  # 
  # `SAVANI perturbation': An initial temperature field in which the
  # temperature is perturbed following the SAVANI shear wave velocity model by
  # Auer and others, which can be downloaded here
  # \url{http://n.ethz.ch/~auerl/savani.tar.bz2}. Information on the vs model
  # can be found in Auer, L., Boschi, L., Becker, T.W., Nissen-Meyer, T. \&
  # Giardini, D., 2014. Savani:A variable resolution wholemantle model of
  # anisotropic shear velocityvariations based on multiple data sets. Journal
  # of GeophysicalResearch: Solid Earth 119.4 (2014): 3006-3034. The scaling
  # between the shear wave perturbation and the temperature perturbation can
  # be set by the user with the 'vs to density scaling' parameter and the
  # 'Thermal expansion coefficient in initial temperature scaling' parameter.
  # The scaling is as follows: $\delta ln \rho (r,\theta,\phi) = \xi \cdot
  # \delta ln v_s(r,\theta, \phi)$ and $\delta T(r,\theta,\phi) = -
  # \frac{1}{\alpha} \delta ln \rho(r,\theta,\phi)$. $\xi$ is the 'vs to
  # density scaling' parameter and $\alpha$ is the 'Thermal expansion
  # coefficient in initial temperature scaling' parameter. The temperature
  # perturbation is added to an otherwise constant temperature (incompressible
  # model) or adiabatic reference profile (compressible model).
  # 
  # `adiabatic': Temperature is prescribed as an adiabatic profile with upper
  # and lower thermal boundary layers, whose ages are given as input
  # parameters.
  # 
  # `ascii data': Implementation of a model in which the initial temperature
  # is derived from files containing data in ascii format. Note the required
  # format of the input data: The first lines may contain any number of
  # comments if they begin with '#', but one of these lines needs to contain
  # the number of grid points in each dimension as for example '# POINTS: 3
  # 3'. The order of the data columns has to be 'x', 'y', 'Temperature [K]' in
  # a 2d model and  'x', 'y', 'z', 'Temperature [K]' in a 3d model, which
  # means that there has to be a single column containing the temperature.
  # Note that the data in the input files need to be sorted in a specific
  # order: the first coordinate needs to ascend first, followed by the second
  # and the third at last in order to assign the correct data to the
  # prescribed coordinates. If you use a spherical model, then the data will
  # still be handled as Cartesian, however the assumed grid changes. 'x' will
  # be replaced by the radial distance of the point to the bottom of the
  # model, 'y' by the azimuth angle and 'z' by the polar angle measured
  # positive from the north pole. The grid will be assumed to be a
  # latitude-longitude grid. Note that the order of spherical coordinates is
  # 'r', 'phi', 'theta' and not 'r', 'theta', 'phi', since this allows for
  # dimension independent expressions.
  # 
  # `function': Specify the initial temperature in terms of an explicit
  # formula. The format of these functions follows the syntax understood by
  # the muparser library, see Section~\ref{sec:muparser-format}.
  # 
  # `harmonic perturbation': An initial temperature field in which the
  # temperature is perturbed following a harmonic function (spherical harmonic
  # or sine depending on geometry and dimension) in lateral and radial
  # direction from an otherwise constant temperature (incompressible model) or
  # adiabatic reference profile (compressible model).
  # 
  # `inclusion shape perturbation': An initial temperature field in which
  # there is an inclusion in a constant-temperature box field. The size,
  # shape, gradient, position, and temperature of the inclusion are defined by
  # parameters.
  # 
  # `mandelbox': Fractal-shaped temperature field.
  # 
  # `perturbed box': An initial temperature field in which the temperature is
  # perturbed slightly from an otherwise constant value equal to one. The
  # perturbation is chosen in such a way that the initial temperature is
  # constant to one along the entire boundary.
  # 
  # `polar box': An initial temperature field in which the temperature is
  # perturbed slightly from an otherwise constant value equal to one. The
  # perturbation is such that there are two poles on opposing corners of the
  # box.
  # 
  # `solidus': This is a temperature initial condition that starts the model
  # close to solidus, it also contains a user defined lithoshpere thickness
  # and with perturbations  in both lithosphere thickness and temperature
  # based on spherical harmonic functions. It was used as the initial
  # condition of early Mars after the freezing of the magma ocean, using the
  # solidus from Parmentier et al., Melt-solid segregation, Fractional magma
  # ocean solidification, and implications for longterm planetary evolution.
  # Luna and Planetary Science, 2007.
  # 
  # `spherical gaussian perturbation': An initial temperature field in which
  # the temperature is perturbed by a single Gaussian added to an otherwise
  # spherically symmetric state. Additional parameters are read from the
  # parameter file in subsection 'Spherical gaussian perturbation'.
  # 
  # `spherical hexagonal perturbation': An initial temperature field in which
  # the temperature is perturbed following an $N$-fold pattern in a specified
  # direction from an otherwise spherically symmetric state. The class's name
  # comes from previous versions when the only option was $N=6$.
  set Model name = function # default: unspecified


  subsection Adiabatic
    # The age of the lower thermal boundary layer, used for the calculation of
    # the half-space cooling model temperature. Units: years if the 'Use years
    # in output instead of seconds' parameter is set; seconds otherwise.
    set Age bottom boundary layer = 0e0

    # The age of the upper thermal boundary layer, used for the calculation of
    # the half-space cooling model temperature. Units: years if the 'Use years
    # in output instead of seconds' parameter is set; seconds otherwise.
    set Age top boundary layer    = 0e0

    # The amplitude (in K) of the initial spherical temperature perturbation
    # at the bottom of the model domain. This perturbation will be added to
    # the adiabatic temperature profile, but not to the bottom thermal
    # boundary layer. Instead, the maximum of the perturbation and the bottom
    # boundary layer temperature will be used.
    set Amplitude                 = 0e0

    # Where the initial temperature perturbation should be placed. If 'center'
    # is given, then the perturbation will be centered along a 'midpoint' of
    # some sort of the bottom boundary. For example, in the case of a box
    # geometry, this is the center of the bottom face; in the case of a
    # spherical shell geometry, it is along the inner surface halfway between
    # the bounding radial lines.
    set Position                  = center

    # The Radius (in m) of the initial spherical temperature perturbation at
    # the bottom of the model domain.
    set Radius                    = 0e0

    # If this value is larger than 0, the initial temperature profile will not
    # be adiabatic, but subadiabatic. This value gives the maximal deviation
    # from adiabaticity. Set to 0 for an adiabatic temperature profile. Units:
    # K.
    # 
    # The function object in the Function subsection represents the
    # compositional fields that will be used as a reference profile for
    # calculating the thermal diffusivity. This function is one-dimensional
    # and depends only on depth. The format of this functions follows the
    # syntax understood by the muparser library, see
    # Section~\ref{sec:muparser-format}.
    set Subadiabaticity           = 0e0


    subsection Function
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The name of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,t
    end

  end

  subsection Ascii data model
    # The name of a directory that contains the model data. This path may
    # either be absolute (if starting with a '/') or relative to the current
    # directory. The path may also include the special text
    # '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the
    # ASPECT source files were located when ASPECT was compiled. This
    # interpretation allows, for example, to reference files located in the
    # 'data/' subdirectory of ASPECT.
    set Data directory = $ASPECT_SOURCE_DIR/data/initial-conditions/ascii-data/test/

    # The file name of the material data. Provide file in format: (Velocity
    # file name).\%s\%d where \%s is a string specifying the boundary of the
    # model according to the names of the boundary indicators (of a box or a
    # spherical shell).\%d is any sprintf integer qualifier, specifying the
    # format of the current file number.
    set Data file name = box_2d.txt

    # Scalar factor, which is applied to the boundary velocity. You might want
    # to use this to scale the velocities to a reference model (e.g. with
    # free-slip boundary) or another plate reconstruction. Another way to use
    # this factor is to convert units of the input files. The unit is assumed
    # to bem/s or m/yr depending on the 'Use years in output instead of
    # seconds' flag. If you provide velocities in cm/yr set this factor to
    # 0.01.
    set Scale factor   = 1
  end

  subsection Function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = (1-z) # default: 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,z   # default: x,y,t
  end

  subsection Harmonic perturbation
    # Doubled first lateral wave number of the harmonic perturbation. Equals
    # the spherical harmonic degree in 3D spherical shells. In all other cases
    # one equals half of a sine period over the model domain. This allows for
    # single up-/downswings. Negative numbers reverse the sign of the
    # perturbation but are not allowed for the spherical harmonic case.
    set Lateral wave number one = 3

    # Doubled second lateral wave number of the harmonic perturbation. Equals
    # the spherical harmonic order in 3D spherical shells. In all other cases
    # one equals half of a sine period over the model domain. This allows for
    # single up-/downswings. Negative numbers reverse the sign of the
    # perturbation.
    set Lateral wave number two = 2

    # The magnitude of the Harmonic perturbation.
    set Magnitude               = 1.0

    # The reference temperature that is perturbed by theharmonic function.
    # Only used in incompressible models.
    set Reference temperature   = 1600.0

    # Doubled radial wave number of the harmonic perturbation.  One equals
    # half of a sine period over the model domain.  This allows for single
    # up-/downswings. Negative numbers  reverse the sign of the perturbation.
    set Vertical wave number    = 1
  end

  subsection Inclusion shape perturbation
    # The background temperature for the temperature field.
    set Ambient temperature   = 1.0

    # The X coordinate for the center of the shape.
    set Center X              = 0.5

    # The Y coordinate for the center of the shape.
    set Center Y              = 0.5

    # The Z coordinate for the center of the shape. This is only necessary for
    # three-dimensional fields.
    set Center Z              = 0.5

    # The gradient of the inclusion to be generated.
    set Inclusion gradient    = constant

    # The shape of the inclusion to be generated.
    set Inclusion shape       = circle

    # The temperature of the inclusion shape. This is only the true
    # temperature in the case of the constant gradient. In all other cases, it
    # gives one endpoint of the temperature gradient for the shape.
    set Inclusion temperature = 0.0

    # The radius of the inclusion to be generated. For shapes with no radius
    # (e.g. square), this will be the width, and for shapes with no width,
    # this gives a general guideline for the size of the shape.
    set Shape radius          = 1.0
  end

  subsection S40RTS perturbation
    # The path to the model data.
    set Data directory                                               = $ASPECT_SOURCE_DIR/data/initial-conditions/S40RTS/

    # The file name of the spherical harmonics coefficients from Ritsema et
    # al.
    set Initial condition file name                                  = S40RTS.sph

    # The maximum order the users specify when reading the data file of
    # spherical harmonic coefficients, which must be smaller than the maximum
    # order the data file stored. This parameter will be used only if 'Specify
    # a lower maximum order' is set to true
    set Maximum order                                                = 20

    # The reference temperature that is perturbed by the spherical harmonic
    # functions. Only used in incompressible models.
    set Reference temperature                                        = 1600.0

    # Option to remove the degree zero component from the perturbation, which
    # will ensure that the laterally averaged temperature for a fixed depth is
    # equal to the background temperature.
    set Remove degree 0 from perturbation                            = true

    # This will set the heterogeneity prescribed by S20RTS or S40RTS to zero
    # down to the specified depth (in meters). Note that your resolution has
    # to be adquate to capture this cutoff. For example if you specify a depth
    # of 660km, but your closest spherical depth layers are only at 500km and
    # 750km (due to a coarse resolution) it will only zero out heterogeneities
    # down to 500km. Similar caution has to be taken when using adaptive
    # meshing.
    set Remove temperature heterogeneity down to specified depth     = -1.7976931348623157e+308

    # Option to use a lower maximum order when reading the data file of
    # spherical harmonic coefficients. This is probably used for the faster
    # tests or when the users only want to see the spherical harmonic pattern
    # up to a certain order.
    set Specify a lower maximum order                                = false

    # The file name of the spline knot locations from Ritsema et al.
    set Spline knots depth file name                                 = Spline_knots.txt

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient in initial temperature scaling = 2e-5

    # This parameter specifies how the perturbation in shear wave velocity as
    # prescribed by S20RTS or S40RTS is scaled into a density perturbation.
    # See the general description of this model for more detailed
    # information.
    set Vs to density scaling                                        = 0.25
  end

  subsection SAVANI perturbation
    # The path to the model data.
    set Data directory                                               = $ASPECT_SOURCE_DIR/data/initial-conditions/SAVANI/

    # The file name of the spherical harmonics coefficients from Auer et al.
    set Initial condition file name                                  = savani.dlnvs.60.m.ab

    # The maximum order the users specify when reading the data file of
    # spherical harmonic coefficients, which must be smaller than the maximum
    # order the data file stored. This parameter will be used only if 'Specify
    # a lower maximum order' is set to true
    set Maximum order                                                = 20

    # The reference temperature that is perturbed by the spherical harmonic
    # functions. Only used in incompressible models.
    set Reference temperature                                        = 1600.0

    # Option to remove the degree zero component from the perturbation, which
    # will ensure that the laterally averaged temperature for a fixed depth is
    # equal to the background temperature.
    set Remove degree 0 from perturbation                            = true

    # This will set the heterogeneity prescribed by SAVANI to zero down to the
    # specified depth (in meters). Note that your resolution has to be adquate
    # to capture this cutoff. For example if you specify a depth of 660km, but
    # your closest spherical depth layers are only at 500km and 750km (due to
    # a coarse resolution) it will only zero out heterogeneities down to
    # 500km. Similar caution has to be taken when using adaptive meshing.
    set Remove temperature heterogeneity down to specified depth     = -1.7976931348623157e+308

    # Option to use a lower maximum order when reading the data file of
    # spherical harmonic coefficients. This is probably used for the faster
    # tests or when the users only want to see the spherical harmonic pattern
    # up to a certain order.
    set Specify a lower maximum order                                = false

    # The file name of the spline knots taken from the 28 spherical layersof
    # SAVANI tomography model.
    set Spline knots depth file name                                 = Spline_knots.txt

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient in initial temperature scaling = 2e-5

    # This parameter specifies how the perturbation in shear wave velocity as
    # prescribed by SAVANI is scaled into a density perturbation. See the
    # general description of this model for more detailed information.
    set Vs to density scaling                                        = 0.25
  end

  subsection Solidus
    # The thickness of lithosphere thickness. Units: m
    set Lithosphere thickness = 0

    # The difference from solidus, use this number to generate initial
    # conditions that close to solidus instead of exactly at solidus. Use
    # small negative number in this parameter to prevent large melting
    # generation at the beginning.   Units: K
    set Supersolidus          = 0e0


    subsection Data
      # The solidus data filename. It is a function of radius or pressure in
      # the following format:
      # Line 1:  Header
      # Line 2:  Unit of temperature (C/K)        Unit of pressure (GPa/kbar)
      # or radius (km/m)
      # Line 3~: Column of solidus temperature    Column of radius/pressure
      # See data/initial-temperature/solidus.Mars as an example.
      # 
      # In order to facilitate placing input files in locations relative to
      # the ASPECT source directory, the file name may also include the
      # special text '$ASPECT_SOURCE_DIR' which will be interpreted as the
      # path in which the ASPECT source files were located when ASPECT was
      # compiled. This interpretation allows, for example, to reference files
      # located in the 'data/' subdirectory of ASPECT.
      set Solidus filename = 
    end

    subsection Perturbation
      # Doubled first lateral wave number of the harmonic perturbation. Equals
      # the spherical harmonic degree in 3D spherical shells. In all other
      # cases one equals half of a sine period over the model domain. This
      # allows for single up-/downswings. Negative numbers reverse the sign of
      # the perturbation but are not allowed for the spherical harmonic case.
      set Lateral wave number one         = 3

      # Doubled second lateral wave number of the harmonic perturbation.
      # Equals the spherical harmonic order in 3D spherical shells. In all
      # other cases one equals half of a sine period over the model domain.
      # This allows for single up-/downswings. Negative numbers reverse the
      # sign of the perturbation.
      set Lateral wave number two         = 2

      # The amplitude of the initial lithosphere thickness perturbation in
      # (m)
      set Lithosphere thickness amplitude = 0e0

      # The amplitude of the initial spherical temperature perturbation in
      # (K)
      set Temperature amplitude           = 0e0
    end

  end

  subsection Spherical gaussian perturbation
    # The amplitude of the perturbation.
    set Amplitude                           = 0.01

    # The angle where the center of the perturbation is placed.
    set Angle                               = 0e0

    # The file from which the initial geotherm table is to be read. The format
    # of the file is defined by what is read in
    # source/initial\_conditions/spherical\_shell.cc.
    set Filename for initial geotherm table = initial-geotherm-table

    # The non-dimensional radial distance where the center of the perturbation
    # is placed.
    set Non-dimensional depth               = 0.7

    # The standard deviation of the Gaussian perturbation.
    set Sigma                               = 0.2

    # The sign of the perturbation.
    set Sign                                = 1
  end

  subsection Spherical hexagonal perturbation
    # The number of convection cells to perturb the system with.
    set Angular mode    = 6

    # Amount of clockwise rotation in degrees to apply to the perturbations.
    # Default is set to -45 in order to provide backwards compatibility.
    set Rotation offset = -45
  end

end


subsection Material model
  # Whether or not (and in the first case, how) to do any averaging of
  # material model output data when constructing the linear systems for
  # velocity/pressure, temperature, and compositions in each time step, as
  # well as their corresponding preconditioners.
  # 
  # Possible choices: none|arithmetic average|harmonic average|geometric
  # average|pick largest|project to Q1|log average
  # 
  # The process of averaging, and where it may be used, is discussed in more
  # detail in Section~\ref{sec:sinker-with-averaging}.
  # 
  # More averaging schemes are available in the averaging material model. This
  # material model is a ``compositing material model'' which can be used in
  # combination with other material models.
  set Material averaging = none

  # The name of the material model to be used in this simulation. There are
  # many material models you can choose from, as listed below. They generally
  # fall into two category: (i) models that implement a particular case of
  # material behavior, (ii) models that modify other models in some way. We
  # sometimes call the latter ``compositing models''. An example of a
  # compositing model is the ``depth dependent'' model below in that it takes
  # another, freely choosable model as its base and then modifies that model's
  # output in some way.
  # 
  # You can select one of the following models:
  # 
  # `Morency and Doin': An implementation of the visco-plastic rheology
  # described by (Morency and Doin, 2004). Compositional fields can each be
  # assigned individual activation energies, reference densities, thermal
  # expansivities, and stress exponents. The effective viscosity is defined as
  # \[v_{eff} = \left(\frac{1}{v_{eff}^v}+\frac{1}{v_{eff}^p}\right)^{-1}\]
  # where \[v_{eff}^v = B \left(\frac{\dot{\epsilon}}{\dot{\epsilon}_{ref}}
  # \right)^{-1+1/n_v} exp\left(\frac{E_a +V_a \rho_m g z}{n_v R T}\right) \]
  # \[v_{eff}^p = (\tau_0 + \gamma \rho_m g z) \left(
  # \frac{\dot{\epsilon}^{-1+1/n_p}} {\dot{\epsilon}_{ref}^{1/n_p}} \right) \]
  # where $B$ is a scaling constant; $\dot{\epsilon}$ is defined as the
  # quadratic sum of the second invariant of the strain rate tensor and a
  # minimum strain rate, $\dot{\epsilon}_0$; $\dot{\epsilon}_{ref}$ is a
  # reference strain rate; $n_v$, and $n_p$ are stress exponents; $E_a$ is the
  # activation energy; $V_a$ is the activation volume; $\rho_m$ is the mantle
  # density; $R$ is the gas constant; $T$ is temperature; $\tau_0$ is the
  # cohestive strength of rocks at the surface; $\gamma$ is a coefficient of
  # yield stress increase with depth; and $z$ is depth.
  # 
  # Note: (Morency and Doin, 2004) defines the second invariant of the strain
  # rate in a nonstandard way. The formulation in the paper is given as
  # $\epsilon_{II} = \sqrt{\frac{1}{2} (\epsilon_{11}^2 + \epsilon_{12}^2)}$
  # where $\epsilon$ is the strain rate tensor. For consistency, that is also
  # the formulation implemented in this material model.
  # 
  # Morency, C., and MP. Doin. "Numerical simulations of the mantle
  # lithosphere delamination." Journal of Geophysical Research: Solid Earth
  # (19782012) 109.B3 (2004).
  # 
  # The value for the components of this formula and additional parameters are
  # read from the parameter file in subsection 'Material model/Morency and
  # Doin'.
  # 
  # `Steinberger': This material model looks up the viscosity from the tables
  # that correspond to the paper of Steinberger and Calderwood 2006 (``Models
  # of large-scale viscous flow in the Earth's mantle with constraints from
  # mineral physics and surface observations'', Geophys. J. Int., 167,
  # 1461-1481, \url{http://dx.doi.org/10.1111/j.1365-246X.2006.03131.x}) and
  # material data from a database generated by the thermodynamics code
  # \texttt{Perplex}, see \url{http://www.perplex.ethz.ch/}. The default
  # example data builds upon the thermodynamic database by Stixrude 2011 and
  # assumes a pyrolitic composition by Ringwood 1988 but is easily replaceable
  # by other data files.
  # 
  # `averaging': The ``averaging'' Material model applies an averaging of the
  # quadrature points within a cell. The values to average are supplied by any
  # of the other available material models. In other words, it is a
  # ``compositing material model''. Parameters related to the average model
  # are read from a subsection ``Material model/Averaging''.
  # 
  # The user must specify a ``Base model'' from which material properties are
  # derived. Furthermore an averaging operation must be selected, where the
  # Choice should be from the list none|arithmetic average|harmonic
  # average|geometric average|pick largest|log average|NWD arithmetic
  # average|NWD harmonic average|NWD geometric average.
  # 
  # NWD stands for Normalized Weighed Distance. The models with this in front
  # of their name work with a weighed average, which means each quadrature
  # point requires an individual weight. The weight is determined by the
  # distance, where the exact relation is determined by a bell shaped curve. A
  # bell shaped curve is a continuous function which is one at it's maximum
  # and exactly zero at and beyond it's limit. This bell shaped curve is
  # spanned around each quadrature point to determine the weighting map for
  # each quadrature point. The used bell shape comes from Lucy (1977). The
  # distance is normalized so the largest distance becomes one. This means
  # that if variable ''Bell shape limit'' is exactly one, the farthest
  # quadrature point is just on the limit and it's weight will be exactly
  # zero. In this plugin it is not implemented as larger and equal than the
  # limit, but larger than, to ensure the the quadrature point at distance
  # zero is always included.
  # 
  # `composition reaction': A material model that behaves in the same way as
  # the simple material model, but includes two compositional fields and a
  # reaction between them. Above a depth given in the input file, the first
  # fields gets converted to the second field.
  # 
  # `depth dependent': The ``depth dependent'' Material model applies a
  # depth-dependent scaling to any of the other available material models. In
  # other words, it is a ``compositing material model''.
  # 
  # Parameters related to the depth dependent model are read from a subsection
  # ``Material model/Depth dependent model''. The user must specify a ``Base
  # model'' from which material properties are derived. Currently the depth
  # dependent model only allows depth dependence of viscosity - other material
  # properties are taken from the ``Base model''. Viscosity $\eta$ at depth
  # $z$ is calculated according to:\begin{equation}\eta(z,p,T,X,...) = \eta(z)
  # \eta_b(p,T,X,..)/\eta_{rb}\end{equation}where $\eta(z)$ is the the
  # depth-dependence specified by the depth dependent model,
  # $\eta_b(p,T,X,...)$ is the viscosity calculated from the base model, and
  # $\eta_{rb}$ is the reference viscosity of the ``Base model''. In addition
  # to the specification of the ``Base model'', the user must specify the
  # method to be used to calculate the depth-dependent viscosity $\eta(z)$ as
  # ``Material model/Depth dependent model/Depth dependence method'', which
  # can be chosen among ``None|Function|File|List''. Each method and the
  # associated parameters are as follows:
  # 
  # ``Function'': read a user-specified parsed function from the input file in
  # a subsection ``Material model/Depth dependent model/Viscosity depth
  # function''. By default, this function is uniformly equal to 1.0e21.
  # Specifying a function that returns a value less than or equal to 0.0
  # anywhere in the model domain will produce an error.
  # 
  # ``File'': read a user-specified file containing viscosity values at
  # specified depths. The file containing depth-dependent viscosities is read
  # from a directory specified by the user as ``Material model/Depth dependent
  # model/Data directory'', from a file with name specified as ``Material
  # model/Depth dependent model/Viscosity depth file''. The format of this
  # file is ascii text and contains two columns with one header line:
  # 
  # example Viscosity depth file:\\Depth (m)    Viscosity
  # (Pa-s)\\0.0000000e+00     1.0000000e+21\\6.7000000e+05     1.0000000e+22\\
  # 
  # Viscosity is interpolated from this file using linear interpolation.
  # ``None'': no depth-dependence. Viscosity is taken directly from ``Base
  # model''
  # 
  # ``List:'': read a comma-separated list of depth values corresponding to
  # the maximum depths of layers having constant depth-dependence $\eta(z)$.
  # The layers must be specified in order of increasing depth, and the last
  # layer in the list must have a depth greater than or equal to the maximal
  # depth of the model. The list of layer depths is specified as ``Material
  # model/Depth dependent model/Depth list'' and the corresponding list of
  # layer viscosities is specified as ``Material model/Depth dependent
  # model/Viscosity list''
  # 
  # `diffusion dislocation':  An implementation of a viscous rheology
  # including diffusion and dislocation creep. Compositional fields can each
  # be assigned individual activation energies, reference densities, thermal
  # expansivities, and stress exponents. The effective viscosity is defined as
  # 
  # 
  # \[v_\text{eff} = \left(\frac{1}{v_\text{eff}^\text{diff}}+
  # \frac{1}{v_\text{eff}^\text{dis}}\right)^{-1}\] where \[v_\text{i} = 0.5 *
  # A^{-\frac{1}{n_i}} d^\frac{m_i}{n_i}
  # \dot{\varepsilon_i}^{\frac{1-n_i}{n_i}} \exp\left(\frac{E_i^* +
  # PV_i^*}{n_iRT}\right)\]
  # 
  # where $d$ is grain size, $i$ corresponds to diffusion or dislocation
  # creep, $\dot{\varepsilon}$ is the square root of the second invariant of
  # the strain rate tensor, $R$ is the gas constant, $T$ is temperature,  and
  # $P$ is pressure. $A_i$ are prefactors, $n_i$ and $m_i$ are stress and
  # grain size exponents $E_i$ are the activation energies and $V_i$ are the
  # activation volumes.
  # 
  # The ratio of diffusion to dislocation strain rate is found by Newton's
  # method, iterating to find the stress which satisfies the above equations.
  # The value for the components of this formula and additional parameters are
  # read from the parameter file in subsection 'Material
  # model/DiffusionDislocation'.
  # 
  # `drucker prager': A material model that has constant values for all
  # coefficients but the density and viscosity. The defaults for all
  # coefficients are chosen to be similar to what is believed to be correct
  # for Earth's mantle. All of the values that define this model are read from
  # a section ``Material model/Drucker Prager'' in the input file, see
  # Section~\ref{parameters:Material_model/Drucker Prager}.Note that the model
  # does not take into account any dependencies of material properties on
  # compositional fields.
  # 
  # The viscosity is computed according to the Drucker Prager frictional
  # plasticity criterion (non-associative) based on a user-defined internal
  # friction angle $\phi$ and cohesion $C$. In 3D:  $\sigma_y = \frac{6 C
  # \cos(\phi)}{\sqrt(3) (3+\sin(\phi))} + \frac{2 P \sin(\phi)}{\sqrt(3)
  # (3+\sin(\phi))}$, where $P$ is the pressure. See for example Zienkiewicz,
  # O. C., Humpheson, C. and Lewis, R. W. (1975), G\'{e}otechnique 25, No. 4,
  # 671-689. With this formulation we circumscribe instead of inscribe the
  # Mohr Coulomb yield surface. In 2D the Drucker Prager yield surface is the
  # same as the Mohr Coulomb surface:  $\sigma_y = P \sin(\phi) + C
  # \cos(\phi)$. Note that in 2D for $\phi=0$, these criteria revert to the
  # von Mises criterion (no pressure dependence). See for example Thieulot, C.
  # (2011), PEPI 188, 47-68.
  # 
  # Note that we enforce the pressure to be positive to prevent negative yield
  # strengths and viscosities.
  # 
  # We then use the computed yield strength to scale back the viscosity on to
  # the yield surface using the Viscosity Rescaling Method described in
  # Kachanov, L. M. (2004), Fundamentals of the Theory of Plasticity, Dover
  # Publications, Inc. (Not Radial Return.)A similar implementation can be
  # found in GALE (https://geodynamics.org/cig/software/gale/gale-manual.pdf).
  # 
  # 
  # To avoid numerically unfavourably large (or even negative) viscosity
  # ranges, we cut off the viscosity with a user-defined minimum and maximum
  # viscosity: $\eta_eff = \frac{1}{\frac{1}{\eta_min + \eta}+
  # \frac{1}{\eta_max}}$.
  # 
  # Note that this model uses the formulation that assumes an incompressible
  # medium despite the fact that the density follows the law
  # $\rho(T)=\rho_0(1-\beta(T-T_{\text{ref}}))$.
  # 
  # `latent heat': A material model that includes phase transitions and the
  # possibility that latent heat is released or absorbed when material crosses
  # one of the phase transitions of up to two different materials
  # (compositional fields). This model implements a standard approximation of
  # the latent heat terms following Christensen \& Yuen, 1985. The change of
  # entropy is calculated as $Delta S = \gamma \frac{\Delta\rho}{\rho^2}$ with
  # the Clapeyron slope $\gamma$ and the density change $\Delta\rho$ of the
  # phase transition being input parameters. The model employs an analytic
  # phase function in the form $X=0.5 \left( 1 + \tanh \left( \frac{\Delta
  # p}{\Delta p_0} \right) \right)$ with $\Delta p = p - p_{transition} -
  # \gamma \left( T - T_{transition} \right)$ and $\Delta p_0$ being the
  # pressure difference over the width of the phase transition (specified as
  # input parameter).
  # 
  # `latent heat melt': A material model that includes the latent heat of
  # melting for two materials: peridotite and pyroxenite. The melting model
  # for peridotite is taken from Katz et al., 2003 (A new parameterization of
  # hydrous mantle melting) and the one for pyroxenite from Sobolev et al.,
  # 2011 (Linking mantle plumes, large igneous provinces and environmental
  # catastrophes). The model assumes a constant entropy change for melting
  # 100\% of the material, which can be specified in the input file. The
  # partial derivatives of entropy with respect to temperature and pressure
  # required for calculating the latent heat consumption are then calculated
  # as product of this constant entropy change, and the respective derivative
  # of the function the describes the melt fraction. This is linearly averaged
  # with respect to the fractions of the two materials present. If no
  # compositional fields are specified in the input file, the model assumes
  # that the material is peridotite. If compositional fields are specified,
  # the model assumes that the first compositional field is the fraction of
  # pyroxenite and the rest of the material is peridotite.
  # 
  # Otherwise, this material model has a temperature- and pressure-dependent
  # density and viscosity and the density and thermal expansivity depend on
  # the melt fraction present. It is possible to extent this model to include
  # a melt fraction dependence of all the material parameters by calling the
  # function melt_fraction in the calculation of the respective parameter.
  # However, melt and solid move with the same velocity and melt extraction is
  # not taken into account (batch melting).
  # 
  # `multicomponent': This model is for use with an arbitrary number of
  # compositional fields, where each field represents a rock type which can
  # have completely different properties from the others. However, each rock
  # type itself has constant material properties.  The value of the
  # compositional field is interpreed as a volume fraction. If the sum of the
  # fields is greater than one, they are renormalized.  If it is less than
  # one, material properties  for ``background mantle'' make up the rest. When
  # more than one field is present, the material properties are averaged
  # arithmetically.  An exception is the viscosity, where the averaging should
  # make more of a difference.  For this, the user selects between arithmetic,
  # harmonic, geometric, or maximum composition averaging.
  # 
  # `simple': A material model that has constant values for all coefficients
  # but the density and viscosity. The defaults for all coefficients are
  # chosen to be similar to what is believed to be correct for Earth's mantle.
  # All of the values that define this model are read from a section
  # ``Material model/Simple model'' in the input file, see
  # Section~\ref{parameters:Material_20model/Simple_20model}.
  # 
  # This model uses the following set of equations for the two coefficients
  # that are non-constant: \begin{align}  \eta(p,T,\mathfrak c) &= \tau(T)
  # \zeta(\mathfrak c) \eta_0, \\  \rho(p,T,\mathfrak c) &= \left(1-\alpha
  # (T-T_0)\right)\rho_0 + \Delta\rho \; c_0,\end{align}where $c_0$ is the
  # first component of the compositional vector $\mathfrak c$ if the model
  # uses compositional fields, or zero otherwise.
  # 
  # The temperature pre-factor for the viscosity formula above is defined as
  # \begin{align}  \tau(T) &= H\left(e^{-\beta (T-T_0)/T_0}\right),
  # \qquad\qquad H(x) = \begin{cases}                            10^{-2} &
  # \text{if}\; x<10^{-2}, \\                            x & \text{if}\;
  # 10^{-2}\le x \le 10^2, \\                            10^{2} & \text{if}\;
  # x>10^{2}, \\                         \end{cases}\end{align} where $\beta$
  # corresponds to the input parameter ``Thermal viscosity exponent'' and
  # $T_0$ to the parameter ``Reference temperature''. If you set $T_0=0$ in
  # the input file, the thermal pre-factor $\tau(T)=1$.
  # 
  # The compositional pre-factor for the viscosity is defined as \begin{align}
  # \zeta(\mathfrak c) &= \xi^{c_0}\end{align} if the model has compositional
  # fields and equals one otherwise. $\xi$ corresponds to the parameter
  # ``Composition viscosity prefactor'' in the input file.
  # 
  # Finally, in the formula for the density, $\alpha$ corresponds to the
  # ``Thermal expansion coefficient'' and $\Delta\rho$ corresponds to the
  # parameter ``Density differential for compositional field 1''.
  # 
  # Note that this model uses the formulation that assumes an incompressible
  # medium despite the fact that the density follows the law
  # $\rho(T)=\rho_0(1-\alpha(T-T_{\text{ref}}))$.
  # 
  # \note{Despite its name, this material model is not exactly ``simple'', as
  # indicated by the formulas above. While it was originally intended to be
  # simple, it has over time acquired all sorts of temperature and
  # compositional dependencies that weren't initially intended. Consequently,
  # there is now a ``simpler'' material model that now fills the role the
  # current model was originally intended to fill.}
  # 
  # `simple compressible': A material model that has constant values for all
  # coefficients but the density. The defaults for all coefficients are chosen
  # to be similar to what is believed to be correct for Earth's mantle. All of
  # the values that define this model are read from a section ``Material
  # model/Simple compressible model'' in the input file, see
  # Section~\ref{parameters:Material_20model/Simple_20compressible_20model}.
  # 
  # This model uses the following equations for the density: \begin{align}
  # \rho(p,T) = \rho_0              \left(1-\alpha (T-T_a)\right)
  # \exp{\beta (P-P_0))}\end{align}
  # 
  # `simpler': A material model that has constant values except for density,
  # which depends linearly on temperature: \begin{align}  \rho(p,T) &=
  # \left(1-\alpha (T-T_0)\right)\rho_0.\end{align}
  # 
  # \note{This material model fills the role the ``simple'' material model was
  # originally intended to fill, before the latter acquired all sorts of
  # complicated temperature and compositional dependencies.}
  set Model name         = simple # default: unspecified


  subsection Averaging
    # Chose the averaging operation to use.
    set Averaging operation = none

    # The name of a material model that will be modified by anaveraging
    # operation. Valid values for this parameter are the names of models that
    # are also valid for the ``Material models/Model name'' parameter. See the
    # documentation for that for more information.
    set Base model          = simple

    # The limit normalized distance between 0 and 1 where the bell shape
    # becomes zero. See the manual for a more information.
    set Bell shape limit    = 1
  end

  subsection Composition reaction model
    # A linear dependency of viscosity on the first compositional field.
    # Dimensionless prefactor. With a value of 1.0 (the default) the viscosity
    # does not depend on the composition.
    set Composition viscosity prefactor 1              = 1.0

    # A linear dependency of viscosity on the second compositional field.
    # Dimensionless prefactor. With a value of 1.0 (the default) the viscosity
    # does not depend on the composition.
    set Composition viscosity prefactor 2              = 1.0

    # If compositional fields are used, then one would frequently want to make
    # the density depend on these fields. In this simple material model, we
    # make the following assumptions: if no compositional fields are used in
    # the current simulation, then the density is simply the usual one with
    # its linear dependence on the temperature. If there are compositional
    # fields, then the density only depends on the first and the second one in
    # such a way that the density has an additional term of the kind $+\Delta
    # \rho \; c_1(\mathbf x)$. This parameter describes the value of $\Delta
    # \rho$ for the first field. Units: $kg/m^3/\textrm{unit change in
    # composition}$.
    set Density differential for compositional field 1 = 0

    # If compositional fields are used, then one would frequently want to make
    # the density depend on these fields. In this simple material model, we
    # make the following assumptions: if no compositional fields are used in
    # the current simulation, then the density is simply the usual one with
    # its linear dependence on the temperature. If there are compositional
    # fields, then the density only depends on the first and the second one in
    # such a way that the density has an additional term of the kind $+\Delta
    # \rho \; c_1(\mathbf x)$. This parameter describes the value of $\Delta
    # \rho$ for the second field. Units: $kg/m^3/\textrm{unit change in
    # composition}$.
    set Density differential for compositional field 2 = 0

    # Above this depth the compositional fields react: The first field gets
    # converted to the second field. Units: $m$.
    set Reaction depth                                 = 0

    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density                              = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat                        = 1250

    # The reference temperature $T_0$. Units: $K$.
    set Reference temperature                          = 293

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity                           = 4.7

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient                  = 2e-5

    # The temperature dependence of viscosity. Dimensionless exponent.
    set Thermal viscosity exponent                     = 0.0

    # The value of the constant viscosity. Units: $kg/m/s$.
    set Viscosity                                      = 5e24
  end

  subsection Depth dependent model
    # The name of a material model that will be modified by a depth dependent
    # viscosity. Valid values for this parameter are the names of models that
    # are also valid for the ``Material models/Model name'' parameter. See the
    # documentation for that for more information.
    set Base model              = simple

    # The path to the model data. The path may also include the special text
    # `$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the
    # ASPECT source files were located when ASPECT was compiled. This
    # interpretation allows, for example, to reference files located in the
    # 'data/' subdirectory of ASPECT.
    set Data directory          = ./

    # Method that is used to specify how the viscosity should vary with
    # depth.
    set Depth dependence method = None

    # A comma-separated list of depth values for use with the ``List'' ``Depth
    # dependence method''. The list must be provided in order ofincreasing
    # depth, and the last value must be greater than or equal to the maximal
    # depth of the model. The depth list is interpreted as a layered viscosity
    # structure and the depth values specify the maximum depths of each
    # layer.
    set Depth list              = 

    # The name of the file containing depth-dependent viscosity data.
    set Viscosity depth file    = visc-depth.txt

    # A comma-separated list of viscosity values, corresponding to the depth
    # values provided in ``Depth list''. The number of viscosity values
    # specified here must be the same as the number of depths provided in
    # ``Depth list''
    set Viscosity list          = 


    subsection Viscosity depth function
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 
      set Function expression = 1.0e21

      # The name of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,t
    end

  end

  subsection Diffusion dislocation
    # List of activation energies, $E_a$, for background mantle and
    # compositional fields, for a total of N+1 values, where N is the number
    # of compositional fields. If only one values is given, then all use the
    # same value.  Units: $J / mol$
    set Activation energies for diffusion creep   = 375e3

    # List of activation energies, $E_a$, for background mantle and
    # compositional fields, for a total of N+1 values, where N is the number
    # of compositional fields. If only one values is given, then all use the
    # same value.  Units: $J / mol$
    set Activation energies for dislocation creep = 530e3

    # List of activation volumes, $V_a$, for background mantle and
    # compositional fields, for a total of N+1 values, where N is the number
    # of compositional fields. If only one value is given, then all use the
    # same value.  Units: $m^3 / mol$
    set Activation volumes for diffusion creep    = 6e-6

    # List of activation volumes, $V_a$, for background mantle and
    # compositional fields, for a total of N+1 values, where N is the number
    # of compositional fields. If only one value is given, then all use the
    # same value.  Units: $m^3 / mol$
    set Activation volumes for dislocation creep  = 1.4e-5

    # List of densities, $\rho$, for background mantle and compositional
    # fields, for a total of N+1 values, where N is the number of
    # compositional fields. If only one values is given, then all use the same
    # value.  Units: $kg / m^3$
    set Densities                                 = 3300.

    # Scaling coefficient for effective viscosity.
    set Effective viscosity coefficient           = 1.0

    # Units: $m$
    set Grain size                                = 1e-3

    # List of grain size exponents, $m_diffusion$, for background mantle and
    # compositional fields, for a total of N+1 values, where N is the number
    # of compositional fields. If only one values is given, then all use the
    # same value.  Units: None
    set Grain size exponents for diffusion creep  = 3

    # Units: $J / (K * kg)$
    set Heat capacity                             = 1.25e3

    # Maximum number of iterations to find the correct diffusion/dislocation
    # strain rate ratio.
    set Maximum strain rate ratio iterations      = 40

    # Upper cutoff for effective viscosity. Units: $Pa s$
    set Maximum viscosity                         = 1e28

    # Stabilizes strain dependent viscosity. Units: $1 / s$
    set Minimum strain rate                       = 1.4e-20

    # Lower cutoff for effective viscosity. Units: $Pa s$
    set Minimum viscosity                         = 1e17

    # List of viscosity prefactors, $A$, for background mantle and
    # compositional fields, for a total of N+1 values, where N is the number
    # of compositional fields. If only one values is given, then all use the
    # same value. Units: $Pa^{-n_{diffusion}} m^{n_{diffusion}/m_{diffusion}}
    # s^{-1}$
    set Prefactors for diffusion creep            = 1.5e-15

    # List of viscosity prefactors, $A$, for background mantle and
    # compositional fields, for a total of N+1 values, where N is the number
    # of compositional fields. If only one values is given, then all use the
    # same value. Units: $Pa^{-n_{dislocation}}
    # m^{n_{dislocation}/m_{dislocation}} s^{-1}$
    set Prefactors for dislocation creep          = 1.1e-16

    # For calculating density by thermal expansivity. Units: $K$
    set Reference temperature                     = 293

    # Reference viscosity for nondimensionalization. Units $Pa s$
    set Reference viscosity                       = 1e22

    # Tolerance for correct diffusion/dislocation strain rate ratio.
    set Strain rate residual tolerance            = 1e-22

    # List of stress exponents, $n_diffusion$, for background mantle and
    # compositional fields, for a total of N+1 values, where N is the number
    # of compositional fields. If only one values is given, then all use the
    # same value.  Units: None
    set Stress exponents for diffusion creep      = 1

    # List of stress exponents, $n_dislocation$, for background mantle and
    # compositional fields, for a total of N+1 values, where N is the number
    # of compositional fields. If only one values is given, then all use the
    # same value.  Units: None
    set Stress exponents for dislocation creep    = 3.5

    # Units: $m^2/s$
    set Thermal diffusivity                       = 0.8e-6

    # List of thermal expansivities for background mantle and compositional
    # fields, for a total of N+1 values, where N is the number of
    # compositional fields. If only one values is given, then all use the same
    # value.  Units: $1 / K$
    set Thermal expansivities                     = 3.5e-5

    # When more than one compositional field is present at a point with
    # different viscosities, we need to come up with an average viscosity at
    # that point.  Select a weighted harmonic, arithmetic, geometric, or
    # maximum composition.
    set Viscosity averaging scheme                = harmonic
  end

  subsection Drucker Prager
    # The reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density             = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat       = 1250

    # The reference temperature $T_0$. The reference temperature is used in
    # the density calculation. Units: $K$.
    set Reference temperature         = 293

    # The value of the reference viscosity $\eta_0$. Units: $kg/m/s$.
    set Reference viscosity           = 1e22

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity          = 4.7

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient = 2e-5


    subsection Viscosity
      # The value of the angle of internal friction $\phi$. For a value of
      # zero, in 2D the von Mises criterion is retrieved. Angles higher than
      # 30 degrees are harder to solve numerically. Units: degrees.
      set Angle of internal friction = 0

      # The value of the cohesion $C$. Units: $Pa$.
      set Cohesion                   = 2e7

      # The value of the maximum viscosity cutoff $\eta_max$. Units: $Pa\;s$.
      set Maximum viscosity          = 1e24

      # The value of the minimum viscosity cutoff $\eta_min$. Units: $Pa\;s$.
      set Minimum viscosity          = 1e19

      # The value of the initial strain rate prescribed during the first
      # nonlinear iteration $\dot{\epsilon}_ref$. Units: $1/s$.
      set Reference strain rate      = 1e-15
    end

  end

  subsection Latent heat
    # A linear dependency of viscosity on composition. Dimensionless
    # prefactor.
    set Composition viscosity prefactor                = 1.0

    # The value of the compressibility $\kappa$. Units: $1/Pa$.
    set Compressibility                                = 5.124e-12

    # A list of phases, which correspond to the Phase transition density
    # jumps. The density jumps occur only in the phase that is given by this
    # phase value. 0 stands for the 1st compositional fields, 1 for the second
    # compositional field and -1 for none of them. List must have the same
    # number of entries as Phase transition depths. Units: $Pa/K$.
    set Corresponding phase for density jump           = 

    # Whether to list phase transitions by depth or pressure. If this
    # parameter is true,then the input file will use Phase transitions depths
    # and Phase transition widthsto define the phase transition. If it is
    # false, the parameter file will read inphase transition data from Phase
    # transition pressures andPhase transition pressure widths.
    set Define transition by depth instead of pressure = true

    # If compositional fields are used, then one would frequently want to make
    # the density depend on these fields. In this simple material model, we
    # make the following assumptions: if no compositional fields are used in
    # the current simulation, then the density is simply the usual one with
    # its linear dependence on the temperature. If there are compositional
    # fields, then the density only depends on the first one in such a way
    # that the density has an additional term of the kind $+\Delta \rho \;
    # c_1(\mathbf x)$. This parameter describes the value of $\Delta \rho$.
    # Units: $kg/m^3/\textrm{unit change in composition}$.
    set Density differential for compositional field 1 = 0

    # A list of Clapeyron slopes for each phase transition. A positive
    # Clapeyron slope indicates that the phase transition will occur in a
    # greater depth, if the temperature is higher than the one given in Phase
    # transition temperatures and in a smaller depth, if the temperature is
    # smaller than the one given in Phase transition temperatures. For
    # negative slopes the other way round. List must have the same number of
    # entries as Phase transition depths. Units: $Pa/K$.
    set Phase transition Clapeyron slopes              = 

    # A list of density jumps at each phase transition. A positive value means
    # that the density increases with depth. The corresponding entry in
    # Corresponding phase for density jump determines if the density jump
    # occurs in peridotite, eclogite or none of them.List must have the same
    # number of entries as Phase transition depths. Units: $kg/m^3$.
    set Phase transition density jumps                 = 

    # A list of depths where phase transitions occur. Values must
    # monotonically increase. Units: $m$.
    set Phase transition depths                        = 

    # A list of widths for each phase transition, in terms of pressure. The
    # phase functions are scaled with these values, leading to a jump betwen
    # phases for a value of zero and a gradual transition for larger values.
    # List must have the same number of entries as Phase transition pressures.
    # Define transition by depth instead of pressure must be set to falseto
    # use this parameter.Units: $Pa$.
    set Phase transition pressure widths               = 

    # A list of pressures where phase transitions occur. Values must
    # monotonically increase. Define transition by depth instead ofpressure
    # must be set to false to use this parameter.Units: $Pa$.
    set Phase transition pressures                     = 

    # A list of temperatures where phase transitions occur. Higher or lower
    # temperatures lead to phase transition ocurring in smaller or greater
    # depths than given in Phase transition depths, depending on the Clapeyron
    # slope given in Phase transition Clapeyron slopes. List must have the
    # same number of entries as Phase transition depths. Units: $K$.
    set Phase transition temperatures                  = 

    # A list of widths for each phase transition, in terms of depth. The phase
    # functions are scaled with these values, leading to a jump betwen phases
    # for a value of zero and a gradual transition for larger values. List
    # must have the same number of entries as Phase transition depths. Units:
    # $m$.
    set Phase transition widths                        = 

    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density                              = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat                        = 1250

    # The reference temperature $T_0$. Units: $K$.
    set Reference temperature                          = 293

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity                           = 2.38

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient                  = 4e-5

    # The temperature dependence of viscosity. Dimensionless exponent.
    set Thermal viscosity exponent                     = 0.0

    # The value of the constant viscosity. Units: $kg/m/s$.
    set Viscosity                                      = 5e24

    # A list of prefactors for the viscosity for each phase. The reference
    # viscosity will be multiplied by this factor to get the corresponding
    # viscosity for each phase. List must have one more entry than Phase
    # transition depths. Units: non-dimensional.
    set Viscosity prefactors                           = 
  end

  subsection Latent heat melt
    # Constant parameter in the quadratic function that approximates the
    # solidus of peridotite. Units: $C$.
    set A1                                             = 1085.7

    # Prefactor of the linear pressure term in the quadratic function that
    # approximates the solidus of peridotite. Units: $C/Pa$.
    set A2                                             = 1.329e-7

    # Prefactor of the quadratic pressure term in the quadratic function that
    # approximates the solidus of peridotite. Units: $C/(Pa^2)$.
    set A3                                             = -5.1e-18

    # Constant parameter in the quadratic function that approximates the
    # lherzolite liquidus used for calculating the fraction of
    # peridotite-derived melt. Units: $C$.
    set B1                                             = 1475.0

    # Prefactor of the linear pressure term in the quadratic function that
    # approximates the  lherzolite liquidus used for calculating the fraction
    # of peridotite-derived melt. Units: $C/Pa$.
    set B2                                             = 8.0e-8

    # Prefactor of the quadratic pressure term in the quadratic function that
    # approximates the  lherzolite liquidus used for calculating the fraction
    # of peridotite-derived melt. Units: $C/(Pa^2)$.
    set B3                                             = -3.2e-18

    # Constant parameter in the quadratic function that approximates the
    # liquidus of peridotite. Units: $C$.
    set C1                                             = 1780.0

    # Prefactor of the linear pressure term in the quadratic function that
    # approximates the liquidus of peridotite. Units: $C/Pa$.
    set C2                                             = 4.50e-8

    # Prefactor of the quadratic pressure term in the quadratic function that
    # approximates the liquidus of peridotite. Units: $C/(Pa^2)$.
    set C3                                             = -2.0e-18

    # A linear dependency of viscosity on composition. Dimensionless
    # prefactor.
    set Composition viscosity prefactor                = 1.0

    # The value of the compressibility $\kappa$. Units: $1/Pa$.
    set Compressibility                                = 5.124e-12

    # Constant parameter in the quadratic function that approximates the
    # solidus of pyroxenite. Units: $C$.
    set D1                                             = 976.0

    # Prefactor of the linear pressure term in the quadratic function that
    # approximates the solidus of pyroxenite. Note that this factor is
    # different from the value given in Sobolev, 2011, because they use the
    # potential temperature whereas we use the absolute temperature. Units:
    # $C/Pa$.
    set D2                                             = 1.329e-7

    # Prefactor of the quadratic pressure term in the quadratic function that
    # approximates the solidus of pyroxenite. Units: $C/(Pa^2)$.
    set D3                                             = -5.1e-18

    # If compositional fields are used, then one would frequently want to make
    # the density depend on these fields. In this simple material model, we
    # make the following assumptions: if no compositional fields are used in
    # the current simulation, then the density is simply the usual one with
    # its linear dependence on the temperature. If there are compositional
    # fields, then the density only depends on the first one in such a way
    # that the density has an additional term of the kind $+\Delta \rho \;
    # c_1(\mathbf x)$. This parameter describes the value of $\Delta \rho$.
    # Units: $kg/m^3/\textrm{unit change in composition}$.
    set Density differential for compositional field 1 = 0

    # Prefactor of the linear depletion term in the quadratic function that
    # approximates the melt fraction of pyroxenite. Units: $C/Pa$.
    set E1                                             = 663.8

    # Prefactor of the quadratic depletion term in the quadratic function that
    # approximates the melt fraction of pyroxenite. Units: $C/(Pa^2)$.
    set E2                                             = -611.4

    # Mass fraction of clinopyroxene in the peridotite to be molten. Units:
    # non-dimensional.
    set Mass fraction cpx                              = 0.15

    # Maximum melt fraction of pyroxenite in this parameterization. At higher
    # temperatures peridotite begins to melt.
    set Maximum pyroxenite melt fraction               = 0.5429

    # The entropy change for the phase transition from solid to melt of
    # peridotite. Units: $J/(kg K)$.
    set Peridotite melting entropy change              = -300

    # The entropy change for the phase transition from solid to melt of
    # pyroxenite. Units: $J/(kg K)$.
    set Pyroxenite melting entropy change              = -400

    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density                              = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat                        = 1250

    # The reference temperature $T_0$. Units: $K$.
    set Reference temperature                          = 293

    # The relative density of melt compared to the solid material. This means,
    # the density change upon melting is this parameter times the density of
    # solid material.Units: non-dimensional.
    set Relative density of melt                       = 0.9

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity                           = 2.38

    # The value of the thermal expansion coefficient $\alpha_s$. Units:
    # $1/K$.
    set Thermal expansion coefficient                  = 4e-5

    # The value of the thermal expansion coefficient $\alpha_f$. Units:
    # $1/K$.
    set Thermal expansion coefficient of melt          = 6.8e-5

    # The temperature dependence of viscosity. Dimensionless exponent.
    set Thermal viscosity exponent                     = 0.0

    # The value of the constant viscosity. Units: $kg/m/s$.
    set Viscosity                                      = 5e24

    # Exponent of the melting temperature in the melt fraction calculation.
    # Units: non-dimensional.
    set beta                                           = 1.5

    # Constant in the linear function that approximates the clinopyroxene
    # reaction coefficient. Units: non-dimensional.
    set r1                                             = 0.5

    # Prefactor of the linear pressure term in the linear function that
    # approximates the clinopyroxene reaction coefficient. Units: $1/Pa$.
    set r2                                             = 8e-11
  end

  subsection Morency and Doin
    # List of activation energies, $E_a$, for background mantle and
    # compositional fields,for a total of N+1 values, where N is the number of
    # compositional fields.If only one values is given, then all use the same
    # value.  Units: $kJ / mol$
    set Activation energies                              = 500

    # ($V_a$). Units: $m^3 / mol$
    set Activation volume                                = 6.4e-6

    # ($\gamma$). Units: None
    set Coefficient of yield stress increase with depth  = 0.25

    # ($\tau_0$). Units: $Pa$
    set Cohesive strength of rocks at the surface        = 117

    # List of densities, $\rho$, for background mantle and compositional
    # fields,for a total of N+1 values, where N is the number of compositional
    # fields.If only one values is given, then all use the same value.  Units:
    # $kg / m^3$
    set Densities                                        = 3300.

    # Units: $J / (K * kg)$
    set Heat capacity                                    = 1.25e3

    # Stabilizes strain dependent viscosity. Units: $1 / s$
    set Minimum strain rate                              = 1.4e-20

    # ($B$). Units: None
    set Preexponential constant for viscous rheology law = 1.24e14

    # ($\dot{\epsilon}_{ref}$). Units: $1 / s$
    set Reference strain rate                            = 6.4e-16

    # For calculating density by thermal expansivity. Units: $K$
    set Reference temperature                            = 293

    # Reference viscosity for nondimensionalization.
    set Reference viscosity                              = 1e22

    # List of stress exponents, $n_p$, for background mantle and compositional
    # fields,for a total of N+1 values, where N is the number of compositional
    # fields.If only one values is given, then all use the same value.  Units:
    # None
    set Stress exponents for plastic rheology            = 30

    # List of stress exponents, $n_v$, for background mantle and compositional
    # fields,for a total of N+1 values, where N is the number of compositional
    # fields.If only one values is given, then all use the same value.  Units:
    # None
    set Stress exponents for viscous rheology            = 3

    # Units: $m^2/s$
    set Thermal diffusivity                              = 0.8e-6

    # List of thermal expansivities for background mantle and compositional
    # fields,for a total of N+1 values, where N is the number of compositional
    # fields.If only one values is given, then all use the same value.  Units:
    # $1 / K$
    set Thermal expansivities                            = 3.5e-5
  end

  subsection Multicomponent
    # List of densities for background mantle and compositional fields,for a
    # total of N+1 values, where N is the number of compositional fields.If
    # only one value is given, then all use the same value.  Units: $kg /
    # m^3$
    set Densities                  = 3300.

    # The reference temperature $T_0$. Units: $K$.
    set Reference temperature      = 293

    # List of specific heats for background mantle and compositional
    # fields,for a total of N+1 values, where N is the number of compositional
    # fields.If only one value is given, then all use the same value. Units:
    # $J /kg /K$
    set Specific heats             = 1250.

    # List of thermal conductivities for background mantle and compositional
    # fields,for a total of N+1 values, where N is the number of compositional
    # fields.If only one value is given, then all use the same value. Units:
    # $W/m/K$
    set Thermal conductivities     = 4.7

    # List of thermal expansivities for background mantle and compositional
    # fields,for a total of N+1 values, where N is the number of compositional
    # fields.If only one value is given, then all use the same value. Units:
    # $1/K$
    set Thermal expansivities      = 4.e-5

    # List of viscosities for background mantle and compositional fields,for a
    # total of N+1 values, where N is the number of compositional fields.If
    # only one value is given, then all use the same value. Units: $Pa s$
    set Viscosities                = 1.e21

    # When more than one compositional field is present at a point with
    # different viscosities, we need to come up with an average viscosity at
    # that point.  Select a weighted harmonic, arithmetic, geometric, or
    # maximum composition.
    set Viscosity averaging scheme = harmonic
  end

  subsection Simple compressible model
    # The value of the reference compressibility. Units: $1/Pa$.
    set Reference compressibility     = 4e-12

    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density             = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat       = 1250

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity          = 4.7

    # The value of the thermal expansion coefficient $\alpha$. Units: $1/K$.
    set Thermal expansion coefficient = 2e-5

    # The value of the constant viscosity $\eta_0$. Units: $kg/m/s$.
    set Viscosity                     = 1e21
  end

  subsection Simple model
    # A linear dependency of viscosity on the first compositional field.
    # Dimensionless prefactor. With a value of 1.0 (the default) the viscosity
    # does not depend on the composition. See the general documentation of
    # this model for a formula that states the dependence of the viscosity on
    # this factor, which is called $\xi$ there.
    set Composition viscosity prefactor                = 1.0

    # If compositional fields are used, then one would frequently want to make
    # the density depend on these fields. In this simple material model, we
    # make the following assumptions: if no compositional fields are used in
    # the current simulation, then the density is simply the usual one with
    # its linear dependence on the temperature. If there are compositional
    # fields, then the density only depends on the first one in such a way
    # that the density has an additional term of the kind $+\Delta \rho \;
    # c_1(\mathbf x)$. This parameter describes the value of $\Delta \rho$.
    # Units: $kg/m^3/\textrm{unit change in composition}$.
    set Density differential for compositional field 1 = 0

    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density                              = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat                        = 1250

    # The reference temperature $T_0$. The reference temperature is used in
    # both the density and viscosity formulas. Units: $K$.
    set Reference temperature                          = 293

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity                           = 1e-6 # default: 4.7

    # The value of the thermal expansion coefficient $\alpha$. Units: $1/K$.
    set Thermal expansion coefficient                  = 1e-4 # default: 2e-5

    # The temperature dependence of viscosity. Dimensionless exponent. See the
    # general documentation of this model for a formula that states the
    # dependence of the viscosity on this factor, which is called $\beta$
    # there.
    set Thermal viscosity exponent                     = 0.0

    # The value of the constant viscosity $\eta_0$. This viscosity may be
    # modified by both temperature and compositional dependencies. Units:
    # $kg/m/s$.
    set Viscosity                                      = 1    # default: 5e24
  end

  subsection Simpler model
    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density             = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat       = 1250

    # The reference temperature $T_0$. The reference temperature is used in
    # the density formula. Units: $K$.
    set Reference temperature         = 293

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity          = 4.7

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient = 2e-5

    # The value of the viscosity $\eta$. Units: $kg/m/s$.
    set Viscosity                     = 5e24
  end

  subsection Steinberger model
    # Whether to use bilinear interpolation to compute material properties
    # (slower but more accurate).
    set Bilinear interpolation                        = true

    # Whether to include a compressible material description.For a description
    # see the manual section.
    set Compressible                                  = false

    # The path to the model data. The path may also include the special text
    # '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the
    # ASPECT source files were located when ASPECT was compiled. This
    # interpretation allows, for example, to reference files located in the
    # 'data/' subdirectory of ASPECT.
    set Data directory                                = $ASPECT_SOURCE_DIR/data/material-model/steinberger/

    # Whether to include latent heat effects in the calculation of thermal
    # expansivity and specific heat. Following the approach of Nakagawa et al.
    # 2009.
    set Latent heat                                   = false

    # The file name of the lateral viscosity data.
    set Lateral viscosity file name                   = temp-viscosity-prefactor.txt

    # The file names of the material data. List with as many components as
    # active compositional fields (material data is assumed to be in order
    # with the ordering of the fields).
    set Material file names                           = pyr-ringwood88.txt

    # The relative cutoff value for lateral viscosity variations caused by
    # temperature deviations. The viscosity may vary laterally by this factor
    # squared.
    set Maximum lateral viscosity variation           = 1e2

    # The maximum viscosity that is allowed in the viscosity calculation.
    # Larger values will be cut off.
    set Maximum viscosity                             = 1e23

    # The minimum viscosity that is allowed in the viscosity calculation.
    # Smaller values will be cut off.
    set Minimum viscosity                             = 1e19

    # The file name of the radial viscosity data.
    set Radial viscosity file name                    = radial-visc.txt

    # The reference viscosity that is used for pressure scaling.
    set Reference viscosity                           = 1e23

    # Whether to use to use the laterally averaged temperature instead of the
    # adiabatic temperature for the viscosity calculation. This ensures that
    # the laterally averaged viscosities remain more or less constant over the
    # model runtime. This behaviour might or might not be desired.
    set Use lateral average temperature for viscosity = true
  end

end


subsection Mesh refinement
  # A list of times so that if the end time of a time step is beyond this
  # time, an additional round of mesh refinement is triggered. This is mostly
  # useful to make sure we can get through the initial transient phase of a
  # simulation on a relatively coarse mesh, and then refine again when we are
  # in a time range that we are interested in and where we would like to use a
  # finer mesh. Units: Each element of the list has units years if the 'Use
  # years in output instead of seconds' parameter is set; seconds otherwise.
  set Additional refinement times              = 

  # The fraction of cells with the smallest error that should be flagged for
  # coarsening.
  set Coarsening fraction                      = 0.05

  # The number of adaptive refinement steps performed after initial global
  # refinement but while still within the first time step.
  set Initial adaptive refinement              = 1                      # default: 2

  # The number of global refinement steps performed on the initial coarse
  # mesh, before the problem is first solved there.
  set Initial global refinement                = 2

  # The minimum refinement level each cell should have, and that can not be
  # exceeded by coarsening. Should not be higher than the 'Initial global
  # refinement' parameter.
  set Minimum refinement level                 = 0

  # If multiple refinement criteria are specified in the ``Strategy''
  # parameter, then they need to be combined somehow to form the final
  # refinement indicators. This is done using the method described by the
  # ``Refinement criteria merge operation'' parameter which can either operate
  # on the raw refinement indicators returned by each strategy (i.e.,
  # dimensional quantities) or using normalized values where the indicators of
  # each strategy are first normalized to the interval $[0,1]$ (which also
  # makes them non-dimensional). This parameter determines whether this
  # normalization will happen.
  set Normalize individual refinement criteria = true

  # If multiple mesh refinement criteria are computed for each cell (by
  # passing a list of more than element to the \texttt{Strategy} parameter in
  # this section of the input file) then one will have to decide which one
  # should win when deciding which cell to refine. The operation that selects
  # from these competing criteria is the one that is selected here. The
  # options are:
  # 
  # \begin{itemize}
  # \item \texttt{plus}: Add the various error indicators together and refine
  # those cells on which the sum of indicators is largest.
  # \item \texttt{max}: Take the maximum of the various error indicators and
  # refine those cells on which the maximal indicators is largest.
  # \end{itemize}The refinement indicators computed by each strategy are
  # modified by the ``Normalize individual refinement criteria'' and
  # ``Refinement criteria scale factors'' parameters.
  set Refinement criteria merge operation      = max

  # A list of scaling factors by which every individual refinement criterion
  # will be multiplied by. If only a single refinement criterion is selected
  # (using the ``Strategy'' parameter, then this parameter has no particular
  # meaning. On the other hand, if multiple criteria are chosen, then these
  # factors are used to weigh the various indicators relative to each other.
  # 
  # If ``Normalize individual refinement criteria'' is set to true, then the
  # criteria will first be normalized to the interval $[0,1]$ and then
  # multiplied by the factors specified here. You will likely want to choose
  # the factors to be not too far from 1 in that case, say between 1 and 10,
  # to avoid essentially disabling those criteria with small weights. On the
  # other hand, if the criteria are not normalized to $[0,1]$ using the
  # parameter mentioned above, then the factors you specify here need to take
  # into account the relative numerical size of refinement indicators (which
  # in that case carry physical units).
  # 
  # You can experimentally play with these scaling factors by choosing to
  # output the refinement indicators into the graphical output of a run.
  # 
  # If the list of indicators given in this parameter is empty, then this
  # indicates that they should all be chosen equal to one. If the list is not
  # empty then it needs to have as many entries as there are indicators chosen
  # in the ``Strategy'' parameter.
  set Refinement criteria scaling factors      = 

  # The fraction of cells with the largest error that should be flagged for
  # refinement.
  set Refinement fraction                      = 0.3

  # Whether or not the postproccessors should be run at the end of each of ths
  # initial adaptive refinement cycles at the of the simulation start.
  set Run postprocessors on initial refinement = false

  # A comma separated list of mesh refinement criteria that will be run
  # whenever mesh refinement is required. The results of each of these
  # criteria, i.e., the refinement indicators they produce for all the cells
  # of the mesh will then be normalized to a range between zero and one and
  # the results of different criteria will then be merged through the
  # operation selected in this section.
  # 
  # The following criteria are available:
  # 
  # `boundary': A class that implements a mesh refinement criterion which
  # always flags all cells on specified boundaries for refinement. This is
  # useful to provide high accuracy for processes at or close to the edge of
  # the model domain.
  # 
  # To use this refinement criterion, you may want to combine it with other
  # refinement criteria, setting the 'Normalize individual refinement
  # criteria' flag and using the 'max' setting for 'Refinement criteria merge
  # operation'.
  # 
  # `composition': A mesh refinement criterion that computes refinement
  # indicators from the compositional fields. If there is more than one
  # compositional field, then it simply takes the sum of the indicators
  # computed from each of the compositional field.
  # 
  # `density': A mesh refinement criterion that computes refinement indicators
  # from a field that describes the spatial variability of the density,
  # $\rho$. Because this quantity may not be a continuous function ($\rho$ and
  # $C_p$ may be discontinuous functions along discontinuities in the medium,
  # for example due to phase changes), we approximate the gradient of this
  # quantity to refine the mesh. The error indicator defined here takes the
  # magnitude of the approximate gradient and scales it by $h_K^{1+d/2}$ where
  # $h_K$ is the diameter of each cell and $d$ is the dimension. This scaling
  # ensures that the error indicators converge to zero as $h_K\rightarrow 0$
  # even if the energy density is discontinuous, since the gradient of a
  # discontinuous function grows like $1/h_K$.
  # 
  # `maximum refinement function': A mesh refinement criterion that ensures a
  # maximum refinement level described by an explicit formula with the depth
  # or position as argument. Which coordinate representation is used is
  # determined by an input parameter. Whatever the coordinate system chosen,
  # the function you provide in the input file will by default depend on
  # variables 'x', 'y' and 'z' (if in 3d). However, the meaning of these
  # symbols depends on the coordinate system. In the Cartesian coordinate
  # system, they simply refer to their natural meaning. If you have selected
  # 'depth' for the coordinate system, then 'x' refers to the depth variable
  # and 'y' and 'z' will simply always be zero. If you have selected a
  # spherical coordinate system, then 'x' will refer to the radial distance of
  # the point to the origin, 'y' to the azimuth angle and 'z' to the polar
  # angle measured positive from the north pole. Note that the order of
  # spherical coordinates is r,phi,theta and not r,theta,phi, since this
  # allows for dimension independent expressions. Each coordinate system also
  # includes a final 't' variable which represents the model time, evaluated
  # in years if the 'Use years in output instead of seconds' parameter is set,
  # otherwise evaluated in seconds. After evaluating the function, its values
  # are rounded to the nearest integer.
  # 
  # The format of these functions follows the syntax understood by the
  # muparser library, see Section~\ref{sec:muparser-format}.
  # 
  # `minimum refinement function': A mesh refinement criterion that ensures a
  # minimum refinement level described by an explicit formula with the depth
  # or position as argument. Which coordinate representation is used is
  # determined by an input parameter. Whatever the coordinate system chosen,
  # the function you provide in the input file will by default depend on
  # variables 'x', 'y' and 'z' (if in 3d). However, the meaning of these
  # symbols depends on the coordinate system. In the Cartesian coordinate
  # system, they simply refer to their natural meaning. If you have selected
  # 'depth' for the coordinate system, then 'x' refers to the depth variable
  # and 'y' and 'z' will simply always be zero. If you have selected a
  # spherical coordinate system, then 'x' will refer to the radial distance of
  # the point to the origin, 'y' to the azimuth angle and 'z' to the polar
  # angle measured positive from the north pole. Note that the order of
  # spherical coordinates is r,phi,theta and not r,theta,phi, since this
  # allows for dimension independent expressions. Each coordinate system also
  # includes a final 't' variable which represents the model time, evaluated
  # in years if the 'Use years in output instead of seconds' parameter is set,
  # otherwise evaluated in seconds. After evaluating the function, its values
  # are rounded to the nearest integer.
  # 
  # The format of these functions follows the syntax understood by the
  # muparser library, see Section~\ref{sec:muparser-format}.
  # 
  # `nonadiabatic temperature': A mesh refinement criterion that computes
  # refinement indicators from the excess temperature(difference between
  # temperature and adiabatic temperature.
  # 
  # `particle density': A mesh refinement criterion that computes refinement
  # indicators based on the density of particles. In practice this plugin
  # equilibrates the number of particles per cell, leading to fine cells in
  # high particle density regions and coarse cells in low particle density
  # regions. This plugin is mostly useful for models with inhomogeneous
  # particle density, e.g. when tracking an initial interface with a high
  # particle density, or when the spatial particle density denotes the region
  # of interest. Additionally, this plugin tends to balance the computational
  # load between processes in parallel computations, because the particle and
  # mesh density is more aligned.
  # 
  # `slope': A class that implements a mesh refinement criterion intended for
  # use with a free surface. It calculates a local slope based on the angle
  # between the surface normal and the local gravity vector. Cells with larger
  # angles are marked for refinement.
  # 
  # To use this refinement criterion, you may want to combine it with other
  # refinement criteria, setting the 'Normalize individual refinement
  # criteria' flag and using the 'max' setting for 'Refinement criteria merge
  # operation'.
  # 
  # `strain rate': A mesh refinement criterion that computes therefinement
  # indicators equal to the strain rate norm computed at the center of the
  # elements.
  # 
  # `temperature': A mesh refinement criterion that computes refinement
  # indicators from the temperature field.
  # 
  # `thermal energy density': A mesh refinement criterion that computes
  # refinement indicators from a field that describes the spatial variability
  # of the thermal energy density, $\rho C_p T$. Because this quantity may not
  # be a continuous function ($\rho$ and $C_p$ may be discontinuous functions
  # along discontinuities in the medium, for example due to phase changes), we
  # approximate the gradient of this quantity to refine the mesh. The error
  # indicator defined here takes the magnitude of the approximate gradient and
  # scales it by $h_K^{1.5}$ where $h_K$ is the diameter of each cell. This
  # scaling ensures that the error indicators converge to zero as
  # $h_K\rightarrow 0$ even if the energy density is discontinuous, since the
  # gradient of a discontinuous function grows like $1/h_K$.
  # 
  # `topography': A class that implements a mesh refinement criterion, which
  # always flags all cells in the uppermost layer for refinement. This is
  # useful to provide high accuracy for processes at or close to the surface.
  # 
  # To use this refinement criterion, you may want to combine it with other
  # refinement criteria, setting the 'Normalize individual refinement
  # criteria' flag and using the 'max' setting for 'Refinement criteria merge
  # operation'.
  # 
  # `velocity': A mesh refinement criterion that computes refinement
  # indicators from the velocity field.
  # 
  # `viscosity': A mesh refinement criterion that computes refinement
  # indicators from a field that describes the spatial variability of the
  # logarithm of the viscosity, $\log\eta$. (We choose the logarithm of the
  # viscosity because it can vary by orders of magnitude.)Because this
  # quantity may not be a continuous function ($\eta$ may be a discontinuous
  # function along discontinuities in the medium, for example due to phase
  # changes), we approximate the gradient of this quantity to refine the mesh.
  # The error indicator defined here takes the magnitude of the approximate
  # gradient and scales it by $h_K^{1+d/2}$ where $h_K$ is the diameter of
  # each cell and $d$ is the dimension. This scaling ensures that the error
  # indicators converge to zero as $h_K\rightarrow 0$ even if the energy
  # density is discontinuous, since the gradient of a discontinuous function
  # grows like $1/h_K$.
  set Strategy                                 = thermal energy density

  # The number of time steps after which the mesh is to be adapted again based
  # on computed error indicators. If 0 then the mesh will never be changed.
  set Time steps between mesh refinement       = 2                      # default: 10


  subsection Boundary
    # A comma separated list of names denoting those boundaries where there
    # should be mesh refinement.
    # 
    # The names of the boundaries listed here can either be numbers (in which
    # case they correspond to the numerical boundary indicators assigned by
    # the geometry object), or they can correspond to any of the symbolic
    # names the geometry object may have provided for each part of the
    # boundary. You may want to compare this with the documentation of the
    # geometry model you use in your model.
    set Boundary refinement indicators = 
  end

  subsection Composition
    # A list of scaling factors by which every individual compositional field
    # will be multiplied by. If only a single compositional field exists, then
    # this parameter has no particular meaning. On the other hand, if multiple
    # criteria are chosen, then these factors are used to weigh the various
    # indicators relative to each other.
    # 
    # If the list of scaling factors given in this parameter is empty, then
    # this indicates that they should all be chosen equal to one. If the list
    # is not empty then it needs to have as many entries as there are
    # compositional fields.
    set Compositional field scaling factors = 
  end

  subsection Maximum refinement function
    # A selection that determines the assumed coordinate system for the
    # function variables. Allowed values are 'depth', 'cartesian' and
    # 'spherical'. 'depth' will create a function, in which only the first
    # variable is non-zero, which is interpreted to be the depth of the point.
    # 'spherical' coordinates are interpreted as r,phi or r,phi,theta in 2D/3D
    # respectively with theta being the polar angle.
    set Coordinate system   = depth

    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,t
  end

  subsection Minimum refinement function
    # A selection that determines the assumed coordinate system for the
    # function variables. Allowed values are 'depth', 'cartesian' and
    # 'spherical'. 'depth' will create a function, in which only the first
    # variable is non-zero, which is interpreted to be the depth of the point.
    # 'spherical' coordinates are interpreted as r,phi or r,phi,theta in 2D/3D
    # respectively with theta being the polar angle.
    set Coordinate system   = depth

    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,t
  end

end


subsection Model settings
  # A comma separated list of names denoting those boundaries on which the
  # composition is fixed and described by the boundary composition object
  # selected in its own section of this input file. All boundary indicators
  # used by the geometry but not explicitly listed here will end up with
  # no-flux (insulating) boundary conditions.
  # 
  # The names of the boundaries listed here can either by numbers (in which
  # case they correspond to the numerical boundary indicators assigned by the
  # geometry object), or they can correspond to any of the symbolic names the
  # geometry object may have provided for each part of the boundary. You may
  # want to compare this with the documentation of the geometry model you use
  # in your model.
  # 
  # This parameter only describes which boundaries have a fixed composition,
  # but not what composition should hold on these boundaries. The latter piece
  # of information needs to be implemented in a plugin in the
  # BoundaryComposition group, unless an existing implementation in this group
  # already provides what you want.
  set Fixed composition boundary indicators   = 

  # A comma separated list of names denoting those boundaries on which the
  # temperature is fixed and described by the boundary temperature object
  # selected in its own section of this input file. All boundary indicators
  # used by the geometry but not explicitly listed here will end up with
  # no-flux (insulating) boundary conditions.
  # 
  # The names of the boundaries listed here can either by numbers (in which
  # case they correspond to the numerical boundary indicators assigned by the
  # geometry object), or they can correspond to any of the symbolic names the
  # geometry object may have provided for each part of the boundary. You may
  # want to compare this with the documentation of the geometry model you use
  # in your model.
  # 
  # This parameter only describes which boundaries have a fixed temperature,
  # but not what temperature should hold on these boundaries. The latter piece
  # of information needs to be implemented in a plugin in the
  # BoundaryTemperature group, unless an existing implementation in this group
  # already provides what you want.
  set Fixed temperature boundary indicators   = bottom, top         # default: 

  # A comma separated list of names denoting those boundaries where there is a
  # free surface. Set to nothing to disable all free surface computations.
  # 
  # The names of the boundaries listed here can either by numbers (in which
  # case they correspond to the numerical boundary indicators assigned by the
  # geometry object), or they can correspond to any of the symbolic names the
  # geometry object may have provided for each part of the boundary. You may
  # want to compare this with the documentation of the geometry model you use
  # in your model.
  set Free surface boundary indicators        = 

  # Whether to include adiabatic heating into the model or not. From a
  # physical viewpoint, adiabatic heating should always be used but may be
  # undesirable when comparing results with known benchmarks that do not
  # include this term in the temperature equation.Warning: deprecated! Add
  # 'adiabatic heating' to the 'List of model names' instead.
  set Include adiabatic heating               = false

  # Whether to include the generation of latent heat at phase transitions into
  # the model or not. From a physical viewpoint, latent heat should always be
  # used but may be undesirable when comparing results with known benchmarks
  # that do not include this term in the temperature equation or when dealing
  # with a model without phase transitions.Warning: deprecated! Add 'latent
  # heat' to the 'List of model names' instead.
  set Include latent heat                     = false

  # Whether to include shear heating into the model or not. From a physical
  # viewpoint, shear heating should always be used but may be undesirable when
  # comparing results with known benchmarks that do not include this term in
  # the temperature equation.Warning: deprecated! Add 'shear heating' to the
  # 'List of model names' instead.
  set Include shear heating                   = false

  # A comma separated list denoting those boundaries on which a traction force
  # is prescribed, i.e., where known external forces act, resulting in an
  # unknown velocity. This is often used to model ``open'' boundaries where we
  # only know the pressure. This pressure then produces a force that is normal
  # to the boundary and proportional to the pressure.
  # 
  # The format of valid entries for this parameter is that of a map given as
  # ``key1 [selector]: value1, key2 [selector]: value2, key3: value3, ...''
  # where each key must be a valid boundary indicator (which is either an
  # integer or the symbolic name the geometry model in use may have provided
  # for this part of the boundary) and each value must be one of the currently
  # implemented boundary traction models. ``selector'' is an optional string
  # given as a subset of the letters 'xyz' that allows you to apply the
  # boundary conditions only to the components listed. As an example, '1 y:
  # function' applies the type 'function' to the y component on boundary 1.
  # Without a selector it will affect all components of the traction.
  set Prescribed traction boundary indicators = 

  # A comma separated list denoting those boundaries on which the velocity is
  # prescribed, i.e., where unknown external forces act to prescribe a
  # particular velocity. This is often used to prescribe a velocity that
  # equals that of overlying plates.
  # 
  # The format of valid entries for this parameter is that of a map given as
  # ``key1 [selector]: value1, key2 [selector]: value2, key3: value3, ...''
  # where each key must be a valid boundary indicator (which is either an
  # integer or the symbolic name the geometry model in use may have provided
  # for this part of the boundary) and each value must be one of the currently
  # implemented boundary velocity models. ``selector'' is an optional string
  # given as a subset of the letters 'xyz' that allows you to apply the
  # boundary conditions only to the components listed. As an example, '1 y:
  # function' applies the type 'function' to the y component on boundary 1.
  # Without a selector it will affect all components of the velocity.
  # 
  # Note that the no-slip boundary condition is a special case of the current
  # one where the prescribed velocity happens to be zero. It can thus be
  # implemented by indicating that a particular boundary is part of the ones
  # selected using the current parameter and using ``zero velocity'' as the
  # boundary values. Alternatively, you can simply list the part of the
  # boundary on which the velocity is to be zero with the parameter ``Zero
  # velocity boundary indicator'' in the current parameter section.
  # 
  # Note that when ``Use years in output instead of seconds'' is set to true,
  # velocity should be given in m/yr.
  set Prescribed velocity boundary indicators = top: function       # default: 

  # Choose none, one or several from
  # 
  # \begin{itemize} \item net rotation \item angular momentum \item net
  # translation \item linear momentum \item net x translation \item net y
  # translation \item net z translation \item linear x momentum \item linear y
  # momentum \item linear z momentum \end{itemize}
  # 
  # These are a selection of operations to remove certain parts of the
  # nullspace from the velocity after solving. For some geometries and certain
  # boundary conditions the velocity field is not uniquely determined but
  # contains free translations and/or rotations. Depending on what you specify
  # here, these non-determined modes will be removed from the velocity field
  # at the end of the Stokes solve step.
  # 
  # 
  # The ``angular momentum'' option removes a rotation such that the net
  # angular momentum is zero. The ``linear * momentum'' options remove
  # translations such that the net momentum in the relevant direction is zero.
  # The ``net rotation'' option removes the net rotation of the domain, and
  # the ``net * translation'' options remove the net translations in the
  # relevant directions.  For most problems there should not be a significant
  # difference between the momentum and rotation/translation versions of
  # nullspace removal, although the momentum versions are more physically
  # motivated. They are equivalent for constant density simulations, and
  # approximately equivalent when the density variations are small.
  # 
  # Note that while more than one operation can be selected it only makes
  # sense to pick one rotational and one translational operation.
  set Remove nullspace                        = 

  # A comma separated list of names denoting those boundaries on which the
  # velocity is tangential and unrestrained, i.e., free-slip where no external
  # forces act to prescribe a particular tangential velocity (although there
  # is a force that requires the flow to be tangential).
  # 
  # The names of the boundaries listed here can either by numbers (in which
  # case they correspond to the numerical boundary indicators assigned by the
  # geometry object), or they can correspond to any of the symbolic names the
  # geometry object may have provided for each part of the boundary. You may
  # want to compare this with the documentation of the geometry model you use
  # in your model.
  set Tangential velocity boundary indicators = left, right, bottom # default: 

  # A comma separated list of names denoting those boundaries on which the
  # velocity is zero.
  # 
  # The names of the boundaries listed here can either by numbers (in which
  # case they correspond to the numerical boundary indicators assigned by the
  # geometry object), or they can correspond to any of the symbolic names the
  # geometry object may have provided for each part of the boundary. You may
  # want to compare this with the documentation of the geometry model you use
  # in your model.
  set Zero velocity boundary indicators       = 
end


subsection Postprocess
  # A comma separated list of postprocessor objects that should be run at the
  # end of each time step. Some of these postprocessors will declare their own
  # parameters which may, for example, include that they will actually do
  # something only every so many time steps or years. Alternatively, the text
  # 'all' indicates that all available postprocessors should be run after each
  # time step.
  # 
  # The following postprocessors are available:
  # 
  # `Stokes residual': A postprocessor that outputs the Stokes residuals
  # during the iterative solver algorithm into a file stokes_residuals.txt in
  # the output directory.
  # 
  # `basic statistics': A postprocessor that computes some simplified
  # statistics like the Rayleigh number and other quantities that only make
  # sense in certain model setups.
  # 
  # `boundary densities': A postprocessor that computes the laterally averaged
  # density at the top and bottom of the domain.
  # 
  # `boundary pressures': A postprocessor that computes the laterally averaged
  # pressure at the top and bottom of the domain.
  # 
  # `command': A postprocessor that executes a command line process.
  # 
  # `composition BPL statistics': A postprocessor that computes some
  # statistics about the compositional fields, if present in this simulation.
  # In particular, it computes maximal and minimal values of each field, as
  # well as the total mass contained in this field as defined by the integral
  # $m_i(t) = \int_\Omega c_i(\mathbf x,t) \; dx$.
  # 
  # `composition statistics': A postprocessor that computes some statistics
  # about the compositional fields, if present in this simulation. In
  # particular, it computes maximal and minimal values of each field, as well
  # as the total mass contained in this field as defined by the integral
  # $m_i(t) = \int_\Omega c_i(\mathbf x,t) \; dx$.
  # 
  # `depth average': A postprocessor that computes depth averaged quantities
  # and writes them into a file <depth_average.ext> in the output directory,
  # where the extension of the file is determined by the output format you
  # select. In addition to the output format, a number of other parameters
  # also influence this postprocessor, and they can be set in the section
  # \texttt{Postprocess/Depth average} in the input file.
  # 
  # In the output files, the $x$-value of each data point corresponds to the
  # depth, whereas the $y$-value corresponds to the simulation time. The time
  # is provided in seconds or, if the global ``Use years in output instead of
  # seconds'' parameter is set, in years.
  # 
  # `dynamic topography': A postprocessor that computes a measure of dynamic
  # topography based on the stress at the surface. The data is written into
  # text files named 'dynamic\_topography.NNNNN' in the output directory,
  # where NNNNN is the number of the time step.
  # 
  # The exact approach works as follows: At the centers of all cells that sit
  # along the top surface, we evaluate the stress and evaluate the component
  # of it in the direction in which gravity acts. In other words, we compute
  # $\sigma_{rr}={\hat g}^T(2 \eta \varepsilon(\mathbf u)- \frac 13
  # (\textrm{div}\;\mathbf u)I)\hat g - p_d$ where $\hat g = \mathbf
  # g/\|\mathbf g\|$ is the direction of the gravity vector $\mathbf g$ and
  # $p_d=p-p_a$ is the dynamic pressure computed by subtracting the adiabatic
  # pressure $p_a$ from the total pressure $p$ computed as part of the Stokes
  # solve. From this, the dynamic topography is computed using the formula
  # $h=\frac{\sigma_{rr}}{\|\mathbf g\| \rho}$ where $\rho$ is the density at
  # the cell center.
  # The file format then consists of lines with Euclidiean coordinates
  # followed by the corresponding topography value.
  # 
  # (As a side note, the postprocessor chooses the cell center instead of the
  # center of the cell face at the surface, where we really are interested in
  # the quantity, since this often gives better accuracy. The results should
  # in essence be the same, though.)
  # 
  # `heat flux statistics': A postprocessor that computes some statistics
  # about the (conductive) heat flux across boundaries. For each boundary
  # indicator (see your geometry description for which boundary indicators are
  # used), the heat flux is computed in outward direction, i.e., from the
  # domain to the outside, using the formula $\int_{\Gamma_i} k \nabla T \cdot
  # \mathbf n$ where $\Gamma_i$ is the part of the boundary with indicator
  # $i$, $k$ is the thermal conductivity as reported by the material model,
  # $T$ is the temperature, and $\mathbf n$ is the outward normal. Note that
  # the quantity so computed does not include any energy transported across
  # the boundary by material transport in cases where $\mathbf u \cdot \mathbf
  # n \neq 0$.
  # 
  # As stated, this postprocessor computes the \textit{outbound} heat flux. If
  # you are interested in the opposite direction, for example from the core
  # into the mantle when the domain describes the mantle, then you need to
  # multiply the result by -1.
  # 
  # `heating statistics': A postprocessor that computes some statistics about
  # heating, averaged by volume.
  # 
  # `mass flux statistics': A postprocessor that computes some statistics
  # about the mass flux across boundaries. For each boundary indicator (see
  # your geometry description for which boundary indicators are used), the
  # mass flux is computed in outward direction, i.e., from the domain to the
  # outside, using the formula $\int_{\Gamma_i} \rho \mathbf v \cdot \mathbf
  # n$ where $\Gamma_i$ is the part of the boundary with indicator $i$, $\rho$
  # is the density as reported by the material model, $\mathbf v$ is the
  # velocity, and $\mathbf n$ is the outward normal.
  # 
  # As stated, this postprocessor computes the \textit{outbound} mass flux. If
  # you are interested in the opposite direction, for example from the core
  # into the mantle when the domain describes the mantle, then you need to
  # multiply the result by -1.
  # 
  # `point values': A postprocessor that evaluates the solution (i.e.,
  # velocity, pressure, temperature, and compositional fields along with other
  # fields that are treated as primary variables) at the end of every time
  # step at a given set of points and then writes this data into the file
  # <point\_values.txt> in the output directory. The points at which the
  # solution should be evaluated are specified in the section
  # \texttt{Postprocess/Point values} in the input file.
  # 
  # In the output file, data is organized as (i) time, (ii) the 2 or 3
  # coordinates of the evaluation points, and (iii) followed by the values of
  # the solution vector at this point. The time is provided in seconds or, if
  # the global ``Use years in output instead of seconds'' parameter is set, in
  # years. In the latter case, the velocity is also converted to meters/year,
  # instead of meters/second.
  # 
  # \note{Evaluating the solution of a finite element field at arbitrarily
  # chosen points is an expensive process. Using this postprocessor will only
  # be efficient if the number of evaluation points is relatively small. If
  # you need a very large number of evaluation points, you should consider
  # extracting this information from the visualization program you use to
  # display the output of the 'visualization' postprocessor.}
  # 
  # `pressure statistics': A postprocessor that computes some statistics about
  # the pressure field.
  # 
  # `spherical velocity statistics': A postprocessor that computes radial,
  # tangential and total RMS velocity.
  # 
  # `temperature statistics': A postprocessor that computes some statistics
  # about the temperature field.
  # 
  # `topography': A postprocessor intended for use with a free surface.  After
  # every step, it loops over all the vertices on the top surface and
  # determines the maximum and minimum topography relative to a reference
  # datum (initial box height for a box geometry model or initial radius for a
  # sphere/spherical shell geometry model).  Outputs topography in meters
  # 
  # `tracers': A Postprocessor that creates tracer particles that follow the
  # velocity field of the simulation. The particles can be generated and
  # propagated in various ways and they can carry a number of constant or
  # time-varying properties. The postprocessor can write output positions and
  # properties of all tracers at chosen intervals, although this is not
  # mandatory. It also allows other parts of the code to query the tracers for
  # information.
  # 
  # `velocity boundary statistics': A postprocessor that computes some
  # statistics about the velocity along the boundaries. For each boundary
  # indicator (see your geometry description for which boundary indicators are
  # used), the min and max velocity magnitude is computed.
  # 
  # `velocity statistics': A postprocessor that computes some statistics about
  # the velocity field.
  # 
  # `viscous dissipation statistics': A postprocessor that computes the
  # viscous dissipationfor the whole domain as: $\frac{1}{2} \int_{V} \sigma :
  # \dot{\epsilon}dV$ = $\int_{V} (-p\nabla \cdot
  # u+2\mu\dot{\epsilon}:\dot{\epsilon} - \frac{2\mu}{3}(\nabla\cdot u)^{2})
  # dV$.
  # 
  # The information produced by this postprocessor is a subset of what is
  # generated by the 'heating statistics' postprocessor.
  # 
  # `visualization': A postprocessor that takes the solution and writes it
  # into files that can be read by a graphical visualization program.
  # Additional run time parameters are read from the parameter subsection
  # 'Visualization'.
  set List of postprocessors = temperature statistics, composition statistics # default: 


  subsection Command
    # Command to execute.
    set Command              = 

    # Whether to run command from all processes (true), or only on process 0
    # (false).
    set Run on all processes = false

    # Select whether \aspect{} should terminate if the command returns a
    # non-zero exit status.
    set Terminate on failure = false
  end

  subsection Depth average
    # A comma separated list which specifies which quantites to average in
    # each depth slice. It defaults to averaging all availabe quantities, but
    # this can be an expensive operation, so you may want to select only a
    # few.
    set List of output variables      = all

    # The number of zones in depth direction within which we are to compute
    # averages. By default, we subdivide the entire domain into 10 depth zones
    # and compute temperature and other averages within each of these zones.
    # However, if you have a very coarse mesh, it may not make much sense to
    # subdivide the domain into so many zones and you may wish to choose less
    # than this default. It may also make computations slightly faster. On the
    # other hand, if you have an extremely highly resolved mesh, choosing more
    # zones might also make sense.
    set Number of zones               = 10

    # The format in which the output shall be produced. The format in which
    # the output is generated also determines the extension of the file into
    # which data is written.
    set Output format                 = gnuplot

    # The time interval between each generation of graphical output files. A
    # value of zero indicates that output should be generated in each time
    # step. Units: years if the 'Use years in output instead of seconds'
    # parameter is set; seconds otherwise.
    set Time between graphical output = 1e8
  end

  subsection Dynamic Topography
    # Option to remove the mean dynamic topography in the outputted data file
    # (not visualization). 'true' subtracts the mean, 'false' leaves the
    # calculated dynamic topography as is.
    set Subtract mean of dynamic topography = false
  end

  subsection Point values
    # The list of points at which the solution should be evaluated. Points
    # need to be separated by semicolons, and coordinates of each point need
    # to be separated by commas.
    set Evaluation points = 
  end

  subsection Tracers
    # File format to output raw particle data in. If you select 'none' no
    # output will be written.Select one of the following models:
    # 
    # `ascii': This particle output plugin writes particle positions and
    # properties into space separated ascii files.
    # 
    # `hdf5': This particle output plugin writes particle positions and
    # properties into hdf5 files.
    # 
    # `vtu': This particle output plugin writes particle positions and
    # properties into vtu files.
    set Data output format        = vtu

    # This parameter is used to decide which method to use to solve the
    # equation that describes the position of particles, i.e.,
    # $\frac{d}{dt}\mathbf x_k(t) = \mathbf u(\mathbf x_k(t),t)$, where $k$ is
    # an index that runs over all particles, and $\mathbf u(\mathbf x,t)$ is
    # the velocity field that results from the Stokes equations.
    # 
    # In practice, the exact velocity $\mathbf u(\mathbf x,t)$ is of course
    # not available, but only a numerical approximation $\mathbf u_h(\mathbf
    # x,t)$. Furthermore, this approximation is only available at discrete
    # time steps, $\mathbf u^n(\mathbf x)=\mathbf u(\mathbf x,t^n)$, and these
    # need to be interpolated between time steps if the integrator for the
    # equation above requires an evaluation at time points between the
    # discrete time steps. If we denote this interpolation in time by
    # $\tilde{\mathbf u}_h(\mathbf x,t)$ where $\tilde{\mathbf u}_h(\mathbf
    # x,t^n)=\mathbf u^n(\mathbf x)$, then the equation the differential
    # equation solver really tries to solve is $\frac{d}{dt}\tilde{\mathbf
    # x}_k(t) =  \tilde{\mathbf u}_h(\mathbf x_k(t),t)$.
    # 
    # As a consequence of these considerations, if you try to assess
    # convergence properties of an ODE integrator -- for example to verify
    # that the RK4 integator converges with forth order --, it is important to
    # recall that the integrator may not solve the equation you think it
    # solves. If, for example, we call the numerical solution of the ODE
    # $\tilde{\mathbf x}_{k,h}(t)$, then the error will typically satisfy a
    # relationship like $$  \| \tilde{\mathbf x}_k(T) - \tilde{\mathbf
    # x}_{k,h}(T) \|  \le  C(T) \Delta t^p$$ where $\Delta t$ is the time step
    # and $p$ the convergence order of the method, and $C(T)$ is a (generally
    # unknown) constant that depends on the end time $T$ at which one compares
    # the solutions. On the other hand, an analytically computed trajectory
    # would likely use the \textit{exact} velocity, and one may be tempted to
    # compute $\| \mathbf x_k(T) - \tilde{\mathbf x}_{k,h}(T) \|$, but this
    # quantity will, in the best case, only satisfy an estimate of the form $$
    # \| \mathbf x_k(T) - \tilde{\mathbf x}_{k,h}(T) \|  \le  C_1(T) \Delta
    # t^p  + C_2(T) \| \mathbf u-\mathbf u_h \|  + C_3(T) \| \mathbf
    # u_h-\tilde{\mathbf u}_h \|$$ with appropriately chosen norms for the
    # second and third term. These second and third terms typically converge
    # to zero at relatively low rates (compared to the order $p$ of the
    # integrator, which can often be chosen relatively high) in the mesh size
    # $h$ and the time step size $\\Delta t$, limiting the overall accuracy of
    # the ODE integrator.
    # 
    # Select one of the following models:
    # 
    # `euler': Explicit Euler scheme integrator, where $y_{n+1} = y_n + dt *
    # v(y_n)$. This requires only one integration substep per timestep.
    # 
    # `rk2': Second Order Runge Kutta integrator $y_{n+1} = y_n +
    # dt*v(t_{n+1/2}, y_{n} + 0.5*k_1)$ where $k_1 = y_n + 0.5*dt*v(t_{n},
    # y_{n})$
    # 
    # `rk4': Runge Kutta fourth order integrator, where $y_{n+1} = y_n +
    # (1/6)*k_1 + (1/3)*k_2 + (1/3)*k_3 + (1/6)*k_4$ and $k_1$, $k_2$, $k_3$,
    # $k_4$ are defined as usual.
    set Integration scheme        = rk2

    # Select one of the following models:
    # 
    # `first particle': Return the properties of the first tracer in the given
    # cell.
    set Interpolation scheme      = first particle

    # A comma separated list of tracer properties that should be tracked. By
    # default none is selected, which means only position, velocity and id of
    # the tracers are output.
    # 
    # The following properties are available:
    # 
    # `function': Implementation of a model in which the tracer property is
    # set by evaluating an explicit function at the initial position of each
    # particle. The function is defined in the parameters in section
    # ``Tracers|Function''. The format of these functions follows the syntax
    # understood by the muparser library, see
    # Section~\ref{sec:muparser-format}.
    # 
    # 
    # 
    # `initial composition': Implementation of a plugin in which the tracer
    # property is given as the initial composition at the particle's initial
    # position. The tracer gets as many properties as there are compositional
    # fields.
    # 
    # 
    # 
    # `initial position': Implementation of a plugin in which the tracer
    # property is given as the initial position of the tracer.
    # 
    # 
    # 
    # `pT path': Implementation of a plugin in which the tracer property is
    # defined as the current pressure and temperature at this position. This
    # can be used to generate pressure-temperature paths of material points
    # over time.
    # 
    # 
    # 
    # `position': Implementation of a plugin in which the tracer property is
    # defined as the current position.
    # 
    # 
    # 
    # `velocity': Implementation of a plugin in which the tracer property is
    # defined as the recent velocity at this position.
    # 
    set List of tracer properties = 

    # Strategy that is used to balance the computationalload across processors
    # for adaptive meshes.
    set Load balancing strategy   = none

    # Upper limit for particle number per cell. This limit is useful for
    # adaptive meshes to prevent coarse cells from slowing down the whole
    # model. It will be checked and enforced after mesh refinement, after MPI
    # transfer of particles and after particle movement. If there are
    # \texttt{n\_number\_of\_particles} $>$ \texttt{max\_particles\_per\_cell}
    # particles in one cell then \texttt{n\_number\_of\_particles} -
    # \texttt{max\_particles\_per\_cell} particles in this cell are randomly
    # chosen and destroyed.
    set Maximum tracers per cell  = 100

    # Lower limit for particle number per cell. This limit is useful for
    # adaptive meshes to prevent fine cells from being empty of particles. It
    # will be checked and enforced after mesh refinement and after particle
    # movement. If there are \texttt{n\_number\_of\_particles} $<$
    # \texttt{min\_particles\_per\_cell} particles in one cell then
    # \texttt{min\_particles\_per\_cell} - \texttt{n\_number\_of\_particles}
    # particles are generated and randomly placed in this cell. If the
    # particles carry properties the individual property plugins control how
    # the properties of the new particles are initialized.
    set Minimum tracers per cell  = 0

    # Total number of tracers to create (not per processor or per element).
    # The number is parsed as a floating point number (so that one can
    # specify, for example, '1e4' particles) but it is interpreted as an
    # integer, of course.
    set Number of tracers         = 1000

    # Select one of the following models:
    # 
    # `ascii file': Generates a distribution of tracers from coordinates
    # specified in an Ascii data file. The file format is a simple text file,
    # with as many columns as spatial dimensions and as many lines as tracers
    # to be generated. Initial comment lines starting with `#' will be
    # discarded.All of the values that define this generator are read from a
    # section ``Particle generator/Ascii file'' in the input file, see
    # Section~\ref{parameters:Particle_20generator/Ascii_20file}.
    # 
    # `probability density function': Generate a random distribution of
    # particles over the entire simulation domain. The probability density is
    # prescribed in the form of a user-prescribed function. The format of this
    # function follows the syntax understood by the muparser library, see
    # Section~\ref{sec:muparser-format}. The return value of the function is
    # always checked to be a non-negative probability density but it can be
    # zero inparts of the domain.
    # 
    # `random uniform': Generates a random uniform distribution of particles
    # over the entire simulation domain.
    # 
    # `uniform box': Generate a uniform distribution of particles over a
    # rectangular domain in 2D or 3D. Uniform here means the particles will be
    # generated with an equal spacing in each spatial dimension. Note that in
    # order to produce a regular distribution the number of generated tracers
    # might not exactly match the one specified in the input file.
    # 
    # `uniform radial': Generate a uniform distribution of particlesover a
    # spherical domain in 2D or 3D. Uniform here means the particles will be
    # generated with an equal spacing in each spherical spatial dimension,
    # i.e., the particles are created at positions that increase linearly with
    # equal spacing in radius, colatitude and longitude around a certain
    # center point. Note that in order to produce a regular distribution the
    # number of generated tracers might not exactly match the one specified in
    # the input file.
    set Particle generator name   = random uniform

    # The time interval between each generation of output files. A value of
    # zero indicates that output should be generated every time step.
    # 
    # Units: years if the 'Use years in output instead of seconds' parameter
    # is set; seconds otherwise.
    set Time between data output  = 1e8

    # Write a summary of the computing time spent in each part of the particle
    # algorithm every time particle output is written. This is mostly useful
    # for benchmarking purposes. ASPECT's usual output of compute times is
    # unaffected by this additional output.
    set Timing output             = false

    # Weight that is associated with the computational load of a single
    # particle. The sum of tracer weights will be added to the sum of cell
    # weights to determine the partitioning of the mesh. Every cell without
    # tracers is associated with a weight of 1000.
    set Tracer weight             = 10


    subsection Function
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The name of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

    subsection Generator
      subsection Ascii file
        # The name of a directory that contains the tracer data. This path may
        # either be absolute (if starting with a '/') or relative to the
        # current directory. The path may also include the special text
        # '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which
        # the ASPECT source files were located when ASPECT was compiled. This
        # interpretation allows, for example, to reference files located in
        # the 'data/' subdirectory of ASPECT.
        set Data directory = $ASPECT_SOURCE_DIR/data/particle/generator/ascii/

        # The name of the tracer file.
        set Data file name = tracer.dat
      end

      subsection Probability density function
        # Sometimes it is convenient to use symbolic constants in the
        # expression that describes the function, rather than having to use
        # its numeric value everywhere the constant appears. These values can
        # be defined using this parameter, in the form `var1=value1,
        # var2=value2, ...'.
        # 
        # A typical example would be to set this runtime parameter to
        # `pi=3.1415926536' and then use `pi' in the expression of the actual
        # formula. (That said, for convenience this class actually defines
        # both `pi' and `Pi' by default, but you get the idea.)
        set Function constants  = 

        # The formula that denotes the function you want to evaluate for
        # particular values of the independent variables. This expression may
        # contain any of the usual operations such as addition or
        # multiplication, as well as all of the common functions such as `sin'
        # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
        # -1)' where the expression evaluates to the second argument if the
        # first argument is true, and to the third argument otherwise. For a
        # full overview of possible expressions accepted see the documentation
        # of the muparser library at http://muparser.beltoforion.de/.
        # 
        # If the function you are describing represents a vector-valued
        # function with multiple components, then separate the expressions for
        # individual components by a semicolon.
        set Function expression = 0

        # The name of the variables as they will be used in the function,
        # separated by commas. By default, the names of variables at which the
        # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z'
        # (in 3d) for spatial coordinates and `t' for time. You can then use
        # these variable names in your function expression and they will be
        # replaced by the values of these variables at which the function is
        # currently evaluated. However, you can also choose a different set of
        # names for the independent variables at which to evaluate your
        # function expression. For example, if you work in spherical
        # coordinates, you may wish to set this input parameter to
        # `r,phi,theta,t' and then use these variable names in your function
        # expression.
        set Variable names      = x,y,t
      end

      subsection Uniform box
        # Maximum x coordinate for the region of tracers.
        set Maximum x = 1

        # Maximum y coordinate for the region of tracers.
        set Maximum y = 1

        # Maximum z coordinate for the region of tracers.
        set Maximum z = 1

        # Minimum x coordinate for the region of tracers.
        set Minimum x = 0

        # Minimum y coordinate for the region of tracers.
        set Minimum y = 0

        # Minimum z coordinate for the region of tracers.
        set Minimum z = 0
      end

      subsection Uniform radial
        # x coordinate for the center of the spherical region, where tracers
        # are generated.
        set Center x          = 0

        # y coordinate for the center of the spherical region, where tracers
        # are generated.
        set Center y          = 0

        # z coordinate for the center of the spherical region, where tracers
        # are generated.
        set Center z          = 0

        # Maximum latitude coordinate for the region of tracers in degrees.
        # Measured from the center position.
        set Maximum latitude  = 3.1415

        # Maximum longitude coordinate for the region of tracers in degrees.
        # Measured from the center position.
        set Maximum longitude = 3.1415

        # Maximum radial coordinate for the region of tracers. Measured from
        # the center position.
        set Maximum radius    = 1

        # Minimum latitude coordinate for the region of tracers in degrees.
        # Measured from the center position.
        set Minimum latitude  = 0

        # Minimum longitude coordinate for the region of tracers in degrees.
        # Measured from the center position.
        set Minimum longitude = 0

        # Minimum radial coordinate for the region of tracers. Measured from
        # the center position.
        set Minimum radius    = 0

        # The number of radial shells of particles that will be
        # generatedaround the central point.
        set Radial layers     = 1
      end

    end

  end

  subsection Visualization
    # deal.II offers the possibility to linearly interpolate output fields of
    # higher order elements to a finer resolution. This somewhat compensates
    # the fact that most visualization software only offers linear
    # interpolation between grid points and therefore the output file is a
    # very coarse representation of the actual solution field. Activating this
    # option increases the spatial resolution in each dimension by a factor
    # equal to the polynomial degree used for the velocity finite element
    # (usually 2). In other words, instead of showing one quadrilateral or
    # hexahedron in the visualization per cell on which \aspect{} computes, it
    # shows multiple (for quadratic elements, it will describe each cell of
    # the mesh on which we compute as $2\times 2$ or $2\times 2\times 2$ cells
    # in 2d and 3d, respectively; correspondingly more subdivisions are used
    # if you use cubic, quartic, or even higher order elements for the
    # velocity).
    # 
    # The effect of using this option can be seen in the following picture
    # showing a variation of the output produced with the input files from
    # Section~\ref{sec:shell-simple-2d}:
    # 
    # \begin{center}
    # \includegraphics[width=0.5\textwidth]{viz/parameters/build-patches}\end{center}Here,
    # the left picture shows one visualization cell per computational cell
    # (i.e., the option is switch off, as is the default), and the right
    # picture shows the same simulation with the option switched on. The
    # images show the same data, demonstrating that interpolating the solution
    # onto bilinear shape functions as is commonly done in visualizing data
    # loses information.
    # 
    # Of course, activating this option also greatly increases the amount of
    # data \aspect{} will write to disk: approximately by a factor of 4 in 2d,
    # and a factor of 8 in 3d, when using quadratic elements for the velocity,
    # and correspondingly more for even higher order elements.
    set Interpolate output            = false

    # A comma separated list of visualization objects that should be run
    # whenever writing graphical output. By default, the graphical output
    # files will always contain the primary variables velocity, pressure, and
    # temperature. However, one frequently wants to also visualize derived
    # quantities, such as the thermodynamic phase that corresponds to a given
    # temperature-pressure value, or the corresponding seismic wave speeds.
    # The visualization objects do exactly this: they compute such derived
    # quantities and place them into the output file. The current parameter is
    # the place where you decide which of these additional output variables
    # you want to have in your output file.
    # 
    # The following postprocessors are available:
    # 
    # `Vp anomaly': A visualization output object that generates output
    # showing the anomaly in the seismic compression wave speed $V_p$ as a
    # spatially variable function with one value per cell. This anomaly is
    # shown as a percentage change relative to the average value of $V_p$ at
    # the depth of this cell.
    # 
    # `Vs anomaly': A visualization output object that generates output
    # showing the anomaly in the seismic shear wave speed $V_s$ as a spatially
    # variable function with one value per cell. This anomaly is shown as a
    # percentage change relative to the average value of $V_s$ at the depth of
    # this cell.
    # 
    # `artificial viscosity': A visualization output object that generates
    # output showing the value of the artificial viscosity on each cell.
    # 
    # `boundary indicators': A visualization output object that generates
    # output about the used boundary indicators. In a loop over the active
    # cells, if a cell lies at a domain boundary, the boundary indicator of
    # the face along the boundary is requested. In case the cell does not lie
    # along any domain boundary, the cell is assigned the value of the largest
    # used boundary indicator plus one. When a cell is situated in one of the
    # corners of the domain, multiple faces will have a boundary indicator.
    # This postprocessor returns the value of the first face along a boundary
    # that is encountered in a loop over all the faces.
    # 
    # `compositional vector': A visualization output object that outputs
    # vectors whose components are derived from compositional fields. Input
    # parameters for this postprocessor are defined in section
    # Postprocess/Visualization/Compositional fields as vectors
    # 
    # `density': A visualization output object that generates output for the
    # density.
    # 
    # `depth': A visualization output postprocessor that outputs the depth for
    # all points inside the domain, as determined by the geometry model.
    # 
    # `dynamic topography': A visualization output object that generates
    # output for the dynamic topography. The approach to determine the dynamic
    # topography requires us to compute the stress tensor and evaluate the
    # component of it in the direction in which gravity acts. In other words,
    # we compute $\sigma_{rr}={\hat g}^T(2 \eta \varepsilon(\mathbf u)-\frac
    # 13 (\textrm{div}\;\mathbf u)I)\hat g - p_d$ where $\hat g = \mathbf
    # g/\|\mathbf g\|$ is the direction of the gravity vector $\mathbf g$ and
    # $p_d=p-p_a$ is the dynamic pressure computed by subtracting the
    # adiabatic pressure $p_a$ from the total pressure $p$ computed as part of
    # the Stokes solve. From this, the dynamic topography is computed using
    # the formula $h=\frac{\sigma_{rr}}{\|\mathbf g\| \rho}$ where $\rho$ is
    # the density at the cell center.
    # 
    # Strictly speaking, the dynamic topography is of course a quantity that
    # is only of interest at the surface. However, we compute it everywhere to
    # make things fit into the framework within which we produce data for
    # visualization. You probably only want to visualize whatever data this
    # postprocessor generates at the surface of your domain and simply ignore
    # the rest of the data generated.
    # 
    # `error indicator': A visualization output object that generates output
    # showing the estimated error or other mesh refinement indicator as a
    # spatially variable function with one value per cell.
    # 
    # `friction heating': A visualization output object that generates output
    # for the amount of friction heating often referred to as $\tau:\epsilon$.
    # More concisely, in the incompressible case, the quantity that is output
    # is defined as $\eta \varepsilon(\mathbf u):\varepsilon(\mathbf u)$ where
    # $\eta$ is itself a function of temperature, pressure and strain rate. In
    # the compressible case, the quantity that's computed is $\eta
    # [\varepsilon(\mathbf u)-\tfrac 13(\textrm{tr}\;\varepsilon(\mathbf
    # u))\mathbf I]:[\varepsilon(\mathbf u)-\tfrac
    # 13(\textrm{tr}\;\varepsilon(\mathbf u))\mathbf I]$.
    # 
    # `gravity': A visualization output object that outputs the gravity
    # vector.
    # 
    # `heating': A visualization output object that generates output for all
    # the heating terms used in the energy equation.
    # 
    # `material properties': A visualization output object that generates
    # output for the material properties given by the material model.There are
    # a number of other visualization postprocessors that offer to write
    # individual material properties. However, they all individually have to
    # evaluate the material model. This is inefficient if one wants to output
    # more than just one or two of the fields provided by the material model.
    # The current postprocessor allows to output a (potentially large) subset
    # of all of the information provided by material models at once, with just
    # a single material model evaluation per output point.
    # 
    # `melt fraction': A visualization output object that generates output for
    # the melt fraction at the temperature and pressure of the current point
    # (batch melting). Does not take into account latent heat. If there are no
    # compositional fields, this postprocessor will visualize the melt
    # fraction of peridotite (calculated using the anhydrous model of Katz,
    # 2003). If there is at least one compositional field, the postprocessor
    # assumes that the  first compositional field is the content of
    # pyroxenite, and will visualize the melt fraction for a mixture of
    # peridotite and pyroxenite (using the melting model of Sobolev, 2011 for
    # pyroxenite). All the parameters that were used in these calculations can
    # be changed in the input file, the most relevant maybe being the mass
    # fraction of Cpx in peridotite in the Katz melting model (Mass fraction
    # cpx), which right now has a default of 15\%. The corresponding
    # p-T-diagrams can be generated by running the tests
    # melt\_postprocessor\_peridotite and melt\_postprocessor\_pyroxenite.
    # 
    # `nonadiabatic pressure': A visualization output object that generates
    # output for the non-adiabatic component of the pressure.
    # 
    # `nonadiabatic temperature': A visualization output object that generates
    # output for the non-adiabatic component of the pressure.
    # 
    # `particle count': A visualization output object that generates output
    # about the number of particles per cell.
    # 
    # `partition': A visualization output object that generates output for the
    # parallel partition that every cell of the mesh is associated with.
    # 
    # `seismic vp': A visualization output object that generates output for
    # the seismic P-wave speed.
    # 
    # `seismic vs': A visualization output object that generates output for
    # the seismic S-wave speed.
    # 
    # `shear stress': A visualization output object that generates output for
    # the 3 (in 2d) or 6 (in 3d) components of the shear stress tensor, i.e.,
    # for the components of the tensor $2\eta\varepsilon(\mathbf u)$ in the
    # incompressible case and $2\eta\left[\varepsilon(\mathbf u)-\tfrac
    # 13(\textrm{tr}\;\varepsilon(\mathbf u))\mathbf I\right]$ in the
    # compressible case. The shear stress differs from the full stress tensor
    # by the absence of the pressure.
    # 
    # `specific heat': A visualization output object that generates output for
    # the specific heat $C_p$.
    # 
    # `strain rate': A visualization output object that generates output for
    # the norm of the strain rate, i.e., for the quantity
    # $\sqrt{\varepsilon(\mathbf u):\varepsilon(\mathbf u)}$ in the
    # incompressible case and $\sqrt{[\varepsilon(\mathbf u)-\tfrac
    # 13(\textrm{tr}\;\varepsilon(\mathbf u))\mathbf I]:[\varepsilon(\mathbf
    # u)-\tfrac 13(\textrm{tr}\;\varepsilon(\mathbf u))\mathbf I]}$ in the
    # compressible case.
    # 
    # `stress': A visualization output object that generates output for the 3
    # (in 2d) or 6 (in 3d) components of the stress tensor, i.e., for the
    # components of the tensor $2\eta\varepsilon(\mathbf u)+pI$ in the
    # incompressible case and $2\eta\left[\varepsilon(\mathbf u)-\tfrac
    # 13(\textrm{tr}\;\varepsilon(\mathbf u))\mathbf I\right]+pI$ in the
    # compressible case.
    # 
    # `thermal conductivity': A visualization output object that generates
    # output for the thermal conductivity $k$.
    # 
    # `thermal diffusivity': A visualization output object that generates
    # output for the thermal diffusivity $\kappa$=$\frac{k}{\rho c_p}$, with
    # $k$ the thermal conductivity.
    # 
    # `thermal expansivity': A visualization output object that generates
    # output for the thermal expansivity.
    # 
    # `thermodynamic phase': A visualization output object that generates
    # output for the integer number of the phase that is thermodynamically
    # stable at the temperature and pressure of the current point.
    # 
    # `vertical heat flux': A visualization output object that generates
    # output for the heat flux in the vertical direction, which is the sum of
    # the advective and the conductive heat flux, with the sign convention of
    # positive flux upwards.
    # 
    # `viscosity': A visualization output object that generates output for the
    # viscosity.
    # 
    # `viscosity ratio': A visualization output object that generates output
    # for the ratio between dislocation viscosity and diffusion viscosity.
    set List of output variables      = 

    # VTU file output supports grouping files from several CPUs into a given
    # number of files using MPI I/O when writing on a parallel filesystem.
    # Select 0 for no grouping. This will disable parallel file output and
    # instead write one file per processor. A value of 1 will generate one big
    # file containing the whole solution, while a larger value will create
    # that many files (at most as many as there are mpi ranks).
    set Number of grouped files       = 0

    # The file format to be used for graphical output.
    set Output format                 = vtu

    # For free surface computations Aspect uses an
    # Arbitrary-Lagrangian-Eulerian formulation to handle deforming the
    # domain, so the mesh has its own velocity field.  This may be written as
    # an output field by setting this parameter to true.
    set Output mesh velocity          = false

    # On large clusters it can be advantageous to first write the output to a
    # temporary file on a local file system and later move this file to a
    # network file system. If this variable is set to a non-empty string it
    # will be interpreted as a temporary storage location.
    set Temporary output location     = 

    # The time interval between each generation of graphical output files. A
    # value of zero indicates that output should be generated in each time
    # step. Units: years if the 'Use years in output instead of seconds'
    # parameter is set; seconds otherwise.
    set Time between graphical output = 1e8

    # File operations can potentially take a long time, blocking the progress
    # of the rest of the model run. Setting this variable to 'true' moves this
    # process into a background thread, while the rest of the model
    # continues.
    set Write in background thread    = false


    subsection Compositional fields as vectors
      # A list of sets of compositional fields which should be output as
      # vectors. Sets are separated from each other by semicolons and vector
      # components within each set are separated by commas (e.g. $vec1_x$,
      # $vec1_y$ ; $vec2_x$, $vec2_y$) where each name must be a defined named
      # compositional field. If only one name is given in a set, it is
      # interpreted as the first in a sequence of dim consecutive
      # compositional fields.
      set Names of fields  = 

      # Names of vectors as they will appear in the output.
      set Names of vectors = 
    end

    subsection Dynamic Topography
      # Option to remove the mean dynamic topography in the outputted data
      # file (not visualization). 'true' subtracts the mean, 'false' leaves
      # the calculated dynamic topography as is.
      set Subtract mean of dynamic topography = false
    end

    subsection Material properties
      # A comma separated list of material properties that should be written
      # whenever writing graphical output. By default, the material properties
      # will always contain the density, thermal expansivity, specific heat
      # and viscosity. The following material properties are available:
      # 
      # viscosity|density|thermal expansivity|specific heat|thermal
      # conductivity|thermal diffusivity|compressibility|entropy derivative
      # temperature|entropy derivative pressure|reaction terms
      set List of material properties = density,thermal expansivity,specific heat,viscosity
    end

    subsection Melt fraction
      # Constant parameter in the quadratic function that approximates the
      # solidus of peridotite. Units: $C$.
      set A1                = 1085.7

      # Prefactor of the linear pressure term in the quadratic function that
      # approximates the solidus of peridotite. Units: $C/Pa$.
      set A2                = 1.329e-7

      # Prefactor of the quadratic pressure term in the quadratic function
      # that approximates the solidus of peridotite. Units: $C/(Pa^2)$.
      set A3                = -5.1e-18

      # Constant parameter in the quadratic function that approximates the
      # lherzolite liquidus used for calculating the fraction of
      # peridotite-derived melt. Units: $C$.
      set B1                = 1475.0

      # Prefactor of the linear pressure term in the quadratic function that
      # approximates the  lherzolite liquidus used for calculating the
      # fraction of peridotite-derived melt. Units: $C/Pa$.
      set B2                = 8.0e-8

      # Prefactor of the quadratic pressure term in the quadratic function
      # that approximates the  lherzolite liquidus used for calculating the
      # fraction of peridotite-derived melt. Units: $C/(Pa^2)$.
      set B3                = -3.2e-18

      # Constant parameter in the quadratic function that approximates the
      # liquidus of peridotite. Units: $C$.
      set C1                = 1780.0

      # Prefactor of the linear pressure term in the quadratic function that
      # approximates the liquidus of peridotite. Units: $C/Pa$.
      set C2                = 4.50e-8

      # Prefactor of the quadratic pressure term in the quadratic function
      # that approximates the liquidus of peridotite. Units: $C/(Pa^2)$.
      set C3                = -2.0e-18

      # Constant parameter in the quadratic function that approximates the
      # solidus of pyroxenite. Units: $C$.
      set D1                = 976.0

      # Prefactor of the linear pressure term in the quadratic function that
      # approximates the solidus of pyroxenite. Note that this factor is
      # different from the value given in Sobolev, 2011, because they use the
      # potential temperature whereas we use the absolute temperature. Units:
      # $C/Pa$.
      set D2                = 1.329e-7

      # Prefactor of the quadratic pressure term in the quadratic function
      # that approximates the solidus of pyroxenite. Units: $C/(Pa^2)$.
      set D3                = -5.1e-18

      # Prefactor of the linear depletion term in the quadratic function that
      # approximates the melt fraction of pyroxenite. Units: $C/Pa$.
      set E1                = 663.8

      # Prefactor of the quadratic depletion term in the quadratic function
      # that approximates the melt fraction of pyroxenite. Units:
      # $C/(Pa^2)$.
      set E2                = -611.4

      # Mass fraction of clinopyroxene in the peridotite to be molten. Units:
      # non-dimensional.
      set Mass fraction cpx = 0.15

      # Exponent of the melting temperature in the melt fraction calculation.
      # Units: non-dimensional.
      set beta              = 1.5

      # Constant in the linear function that approximates the clinopyroxene
      # reaction coefficient. Units: non-dimensional.
      set r1                = 0.5

      # Prefactor of the linear pressure term in the linear function that
      # approximates the clinopyroxene reaction coefficient. Units: $1/Pa$.
      set r2                = 8e-11
    end

  end

end


subsection Prescribed Stokes solution
  # Select one of the following models:
  # 
  # `ascii data': Implementation of a model in which the velocityis derived
  # from files containing data in ascii format. Note the required format of
  # the input data: The first lines may contain any number of comments if they
  # begin with '#', but one of these lines needs to contain the number of grid
  # points in each dimension as for example '# POINTS: 3 3'. The order of the
  # data columns has to be 'x', 'y', 'v$_x$' , 'v$_y$' in a 2d model and  'x',
  # 'y', 'z', 'v$_x$' , 'v$_y$' , 'v$_z$' in a 3d model. Note that the data in
  # the input files need to be sorted in a specific order: the first
  # coordinate needs to ascend first, followed by the second and the third at
  # last in order to assign the correct data to the prescribed coordinates. If
  # you use a spherical model, then the data will still be handled as
  # Cartesian, however the assumed grid changes. 'x' will be replaced by the
  # radial distance of the point to the bottom of the model, 'y' by the
  # azimuth angle and 'z' by the polar angle measured positive from the north
  # pole. The grid will be assumed to be a latitude-longitude grid. Note that
  # the order of spherical coordinates is 'r', 'phi', 'theta' and not 'r',
  # 'theta', 'phi', since this allows for dimension independent expressions.
  # 
  # `circle': This value describes a vector field that rotates around the
  # z-axis with constant angular velocity (i.e., with a velocity that
  # increases with distance from the axis). The pressure is set to zero.
  # 
  # `function': This plugin allows to prescribe the Stokes solution for the
  # velocity and pressure field in terms of an explicit formula. The format of
  # these functions follows the syntax understood by the muparser library, see
  # Section~\ref{sec:muparser-format}.
  set Model name = unspecified


  subsection Ascii data model
    # The name of a directory that contains the model data. This path may
    # either be absolute (if starting with a '/') or relative to the current
    # directory. The path may also include the special text
    # '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the
    # ASPECT source files were located when ASPECT was compiled. This
    # interpretation allows, for example, to reference files located in the
    # 'data/' subdirectory of ASPECT.
    set Data directory = $ASPECT_SOURCE_DIR/data/prescribed-stokes-solution/

    # The file name of the material data. Provide file in format: (Velocity
    # file name).\%s\%d where \%s is a string specifying the boundary of the
    # model according to the names of the boundary indicators (of a box or a
    # spherical shell).\%d is any sprintf integer qualifier, specifying the
    # format of the current file number.
    set Data file name = box_2d.txt

    # Scalar factor, which is applied to the boundary velocity. You might want
    # to use this to scale the velocities to a reference model (e.g. with
    # free-slip boundary) or another plate reconstruction. Another way to use
    # this factor is to convert units of the input files. The unit is assumed
    # to bem/s or m/yr depending on the 'Use years in output instead of
    # seconds' flag. If you provide velocities in cm/yr set this factor to
    # 0.01.
    set Scale factor   = 1
  end

  subsection Pressure function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,t
  end

  subsection Velocity function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0; 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,t
  end

end


subsection Termination criteria
  # Whether to checkpoint the simulation right before termination.
  set Checkpoint on termination = false

  # Terminate the simulation once the specified timestep has been reached.
  set End step                  = 100

  # A comma separated list of termination criteria that will determine when
  # the simulation should end. Whether explicitly stated or not, the ``end
  # time'' termination criterion will always be used.The following termination
  # criteria are available:
  # 
  # `end step': Terminate the simulation once the specified timestep has been
  # reached.
  # 
  # `end time': Terminate the simulation once the end time specified in the
  # input file has been reached. Unlike all other termination criteria, this
  # criterion is \textit{always} active, whether it has been explicitly
  # selected or not in the input file (this is done to preserve historical
  # behavior of \aspect{}, but it also likely does not inconvenience anyone
  # since it is what would be selected in most cases anyway).
  # 
  # `steady state velocity': A criterion that terminates the simulation when
  # the RMS of the velocity field stays within a certain range for a specified
  # period of time.
  # 
  # `user request': Terminate the simulation gracefully when a file with a
  # specified name appears in the output directory. This allows the user to
  # gracefully exit the simulation at any time by simply creating such a file
  # using, for example, \texttt{touch output/terminate}. The file's location
  # is chosen to be in the output directory, rather than in a generic location
  # such as the Aspect directory, so that one can run multiple simulations at
  # the same time (which presumably write to different output directories) and
  # can selectively terminate a particular one.
  set Termination criteria      = end time


  subsection Steady state velocity
    # The maximum relative deviation of the RMS in recent simulation time for
    # the system to be considered in steady state. If the actual deviation is
    # smaller than this number, then the simulation will be terminated.
    set Maximum relative deviation = 0.05

    # The minimum length of simulation time that the system should be in
    # steady state before termination.Units: years if the 'Use years in output
    # instead of seconds' parameter is set; seconds otherwise.
    set Time in steady state       = 1e7
  end

  subsection User request
    # The name of a file that, if it exists in the output directory (whose
    # name is also specified in the input file) will lead to termination of
    # the simulation. The file's location is chosen to be in the output
    # directory, rather than in a generic location such as the Aspect
    # directory, so that one can run multiple simulations at the same time
    # (which presumably write to different output directories) and can
    # selectively terminate a particular one.
    set File name = terminate-aspect
  end

end


